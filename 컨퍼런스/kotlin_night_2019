코틀린 나이트 2019
================

1. 인공지능은 프로그래머를 대체할까?
  - 구글 딥마인드 립넷 : 입모양을 보고 말하는걸 유추
  - 스웨덴 영원한 직업프로젝트
    - 2025년부터 120세까지 출근버튼과 퇴근버튼만 누루면 됨.
  - 인류는 앞으로 어떤 역할을 할것인가?
  - 인류는 고민해야한다. 현시점부터 약 20년간?

2. 자바 개발자 관점에서 왜 코틀린인가?
  - 자바와 코틀린
    - 자바는 장황하다.
    - 엔티티 설계에서 리스트부터 불편하다.
    - 롬복은 JDK버전을 탄다.
    - 코틀린의 data class
      - 롬복의 @Data와 비슷
    - 자바 eco시스템
        - java와 kotlin간의 fully호환됨
    - 자바를 대체하기 위해서 스칼라를 사용하는건 아직 여러 허들이 있음.
    - 자바 -> 코틀린 진입장벽이 낮음.
    - 자바의 널포인트 이셉션 - 10억불짜리 실수 : 코틀린에선 없음.
      - null을 완전히 없앨수 없음.
      - NPE을 최소화할 수 있음.
      - 엘비스오퍼레이터 ?:
      - 코틀린 확장 함수
        - joinToList등 일반함수와는 다르게 노란색으로 표시
    - Data class
      - 코틀린은 함수형 프로그래밍에 조금 더 가깝다.
      - 함수가 1급 객체
      - object : 싱글톤 문법지원
    - 자바와 코틀린이 호환되기 때문에 점진적 변환/통합이 가능하다.

3. 이펙티브 자바와 코틀린
  - 코틀린 : 가독성, 간결성, 안정성, 자바와의 상호운영성
  - 이펙티브 자바 -> 코틀린에 적용
  - 아이템2:
    - 자바 : 생성자 -> 빈즈 패턴 -> 빌더 패턴
    - 코틀린 : 네임드 아규먼츠, 디폴트 아규먼츠
  - 아이템3: 싱글톤
    - 자바 : static final (프라이빗 생성자)
    - 코틀린 : object키워드로 선언
  - 아이템4:
    - 정적 멤버만 담은 유틸리티클래스
    - 자바 : 클래스 내에 메서드
    - 코틀린 : 탑레벨 펑션 사용
  - 아이템18: 상속보다 컴포지션을 사용하라.
    - OOP 언어에 권장사항
    - 상속은 캡슐화를 깨뜨린다.
    - 상속대신 컴포지션과 전달을 사용하자.
    - 래퍼클래스는 하위 클래스보다 견고하고 강력하다.
    - 상속은 다형성을 위한것이다.
    - 코틀린은 래퍼클래스를 by키워드를 통해 간단히 구현할 수 있다.
  - 아이템19: 상속금지
    - 자바는 final 키워드로 금지시킴
    - 코틀린은 기본값이 금지, open으로 상속 할수 있게 열어줘야함
  - 아이템40: @오버라이드 어노테이션을 일관되게 사용해라.
      - 코틀린 : 오버라이드시 무조건 오버라이드 키워드 사용
  - 아이템17: 변경가능성을 최소화 하라.
    - 자바 : final
    - 코틀린 : val
  - 아이템61: 박싱된 기본타입보다 기본타입을 사용하라.
    - 박싱된 기본타입
    - 코틀린 : 박싱된 기본타입이 필요할때만 기본타입으로 컴파일
  - 아이템10,11,12 :
    - 재정의해서 사용하라.
    - 코틀린 text 키워드 사용
  - 아이템?: 예외를 무시하지 마라.
    - 체크드 이셉션
    - 코틀린 : 체크드 이셉션이 없음.
      - 언체크드 이셉션 또한 무시하지 마라.
  - 아이템?: 지연초기화는 시중히 사용하라.
    - 동기화 수준을 최소화 할수 있다.
