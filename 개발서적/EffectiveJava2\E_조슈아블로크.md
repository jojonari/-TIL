Effective Java 2/E - 조슈아 블로크
=============================

> 도서 : Effective Java 2/E
> 저자 : 조슈아 블로크

### 서론
  - 코드는 복사하기 보단 재사용 해야한다.
  - 모듈 간 의존성은 가능한 한 줄여야 한다.
  - 자바는 네 가지 유형의 자료형을 지원한다.
    * interface(annotation 포함)
    * class(enum 포함)
    * array
    * primitive
  - 클래스로 만든 개체(instance)와 배열은 객체(Object)다.
  - 기본 자료형 값들은 객체가 아니다.
  - 메서드의 시그니처는 그 이름과 형식 인자 자료형들로 구성된다.
  - 시그니처에는 메서드 반환값 자료형(return type)은 포함되지 않는다.
  - 공객API라는 용어는 단순히 API라고도 하는데, 프로그래머들이 클래스, 인터페이스, 패키지를 사용할 때 이용하는 클래스, 인터페이스, 생성자, 멤버, 그리고 직렬화 형식(serialized from)을 가리키는 말이다.
    * 줄임말로 interface라고도 한다.

### 객체의 생성과 삭제
  - 규칙 1 : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.
    * 클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다.
    * 장점
      + 생성자와는 달리 팩터리 메서드에는 이름이 있다.
      + 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시해 놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
        - 정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. (객체 통제 클래스)
        - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있고, 객체생성이 불가능한 클래스를 만들 수도 있다. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
      + 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
        - 반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
        - 인터페이스 기반 프레임워크 구현에 적합하다. 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.
        - 인터페이스 기반 프레임워크 기법 덕에 간단해진 것은 단순히 API의 규모가 아니며, 오히려 '개념상의 무게감'이다.
        - 정적팩터리 메서드가 반환하는 객체의 클래스는 정적 팩터리 메서드가 정의된 클래스의 코드가 작성되는 순간에 존재하지 않아도 무방하다.
        - 서비스 제공자 프레임워크는 세 가지의 핵심 컴포넌트로 구성된다.
          1. 서비스 인터페이스
          2. 제공자 등록 API
          3. 서비스 접근 API
          4. 서비스 제공자 인터페이스(option)
      + 형인자 자료형(parameterized type)객체를 만들 때 편하다는 점이다.
        - 자료형 유추 : 정적팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
    * 단점
      + public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.
        - 자바의 컬렉션 프레임워크에 포함된 기본 구현 클래스들의 하위 클래스는 만들 수 없다.
      + 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.
        - 클래스나 인터페이스 주석을 통해 정적팩터리 메서드임을 널리 알리거나, 정적 팩터리 메서드 이름을 지을 때 조심하는 수밖에 없다.
        - 자주 쓰는 이름
          1. valueOf
          2. of
          3. getInstance
          4. newInstance
          5. newType
    * 요약
      - 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다.
      - 정적 팩터리 메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야한다.

  - 규칙 2 : 생성자 인자가 많을 때는 builder패턴 적용을 고려해라.
    * 선택적인자가 많은 상황에서 사용할 수 있는 패턴
      + 점층적 생성자 패턴
        - 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로, 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의가 끝난다.
        - 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.
      + 자바빈 패턴
        - 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수뿐 아니라 선택적 필드의 값들까지 채우는 것이다 .
        - 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 꺠질수 있다.
      + 빌더 패턴
        - 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만든다.
        - 그런다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.
        - Ada나 Python같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
        - 빌더 객체는 여러개의 varargs인자를 받을 수 있는 장점이 있다.
        - 빌더 패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 우 있다.
        - 인자가 설정된 빌더는 훌륭한 추상적 팩터리다.
        - Class.newInstance는 컴파일 시점에 예외 검사가 가능해야한다는 규칙을 깨뜨린다.
        - 객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 단점이 있다.
    * 요약
      - 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유리하다.

  - 규칙 3 : private 생성자나 enum자료형은 싱글턴 패턴을 따르도록 설계하라.
    * 싱글턴은 객체를 하나만 만들 수 있는 클래스다.
    * 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기 어려워질 수가 있다.
      + 싱글턴이 어떤 인터페이스를 구현하는 것이 아니면 가짜 구현으로 대체할 수 없기 때문이다.
    * 싱글턴 객체 생성 방법
      + private로 선언하고 싱글턴 객체는 정적 멤버를 통해 이용한다.
      + public으로 선언된 정적 팩터리 메서드를 이용하는 것
      + 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.

  - 규칙 4 : 객체 생성을 막을 때는 private 생성자를 사용하라.
    * 정적메서드나 필드만 모은 클래스를 이용하고 싶을때
    * 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해봤자 소용없다.
      + 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
    * private 생성자를 클래스에 넣어서 객체생성을 방지 할 수 있다.
      + 이렇게 하면 하위 클래스도 만들수 없다.
      + 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 떄문이다.
  - 규칙 5 : 불필요한 객체는 만들지 말라.
    * 기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다.
    * 객체를 재사용하는 프로그램은 더 빠르고 우아하다.
    * 변경 불가능한 객체는 언제나 재사용할 수 있다.
    * 생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능한 클래스의 경우 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다.
    * 자동 객체화(autoboxing)  
      + 프로그래머들이 자바의 기본자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해준다.
      + 둘간의 변환은 자동으로 이뤄진다.
      + 의미적 차이는 희미해졌지만, 성능차이는 무시하기 어렵다.
    * long과 Long
      + long : 기본 자료형
      + Long : 객체 표현형
    * 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않다록 유의하라.
    * 직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.
    * 방어적 복사 : '새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라'

  - 규칙 6 : 유효기간이 지난 객체 참조는 폐기하라.
    * 만기 참조 : 다시 이용되지 않을 참조
    * 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수문제(널리 알려진 용어로는 '의도치 않은 객체보유'라고 한다.)는 찾아내기 어렵다.
    * 쓸 일 없는 객체 참조는 무조건 null로 만드는 것으로 해결 한다.
    * 객체 참조를 null처리 하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.
    * 변소를 정의할 때 그 유효범위를 최대한 좁게 만들면 자연스럽게 해결된다.
    * 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다.
    * 캐시도 메모리 누수가 흔히 발생하는 장소다.
    * 리스너 등의 역호출자(call back)에서도 메모리누수가 발생한다.
      + 역호출자에 대한 약한 참조만 저장한는 것으로 해결한다.
  - 규칙 7 : 종료자 사용을 피하라
    * 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
    * 자바에서는 더 이상 참조되지 않는 객체에 할당된 공간을 쓰레기 수집기가 알아서 반환하므로 프로그래머 입장에서 특별히 할 일이 없다.
    * 자바는 보통 try-finally 블록이 메모리 이외의 자원을 반환하는데 사용된다.
    * 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다.
    * JVM은 종료자를 천천히 실행하므로 열린 상태의 파일이 많이 남아있을 수 있다.
    * 더딘 실행(tardy finalization) : 클래스에 종료자를 붙여 놓으면, 드믄 일이지만 객체 메모리 반환이 지연될 수도 있다.
    * 지속성이 보장되어야 하는 중요 상태 정보(critical persistent)는 종료자로 갱신하면 안 된다.
    * 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
    * 명시적인 종료 메서드를 하나 정의하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록하라.
      + 한 가지 명심할 것은 종료여부를 객체 안에 보관해야 한다는 것
      + 유효하지 않은 객체임을 표시하는 private필드를 하나두고, 모든 메서드 맨앞에 해당 필드를 검사하는 코드를 두어, 이미 종료된 객체에 메서드를 호출하면 IllegalStateException이 던져지도록 해야한다는 것이다.
    * 명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다.
      + 객체종료를 보장하기 위해서
    * 종료자 사용이 적합한 두 번째 경우는 네이티브 피어와 연결된 객체를 다룰때다.
      + 네이티브 피어는 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 네이티브 객체를 말한다.
    * 하위 클래스에서 상위 클래스 종료자를 재정의(override)하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다.
    * 자원 반환에 대한 최종적 안전장치를 구현하거나, 그다지 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말라는 것이다.
      + 굳이 종료자를 사용해야 하는 드문 상황에 처했다면 super.finalize 호출을 잊지 말자.

### 모든 객체의 공통 메서드
  - Object는 객체 생성이 가능한 클래스(concrete class)이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다.
  - 규칙 8 : equals를 재정의할 떄는 일반 규약을 따르라
    * equals를 재정의하지 않기 위한 조건
      + 각각의 객체가 고유하다.
      + 클래스에 "논리적 동일성(logical equality)" 검사 방법이 있건 없건 상관없다.
      + 상위 클래스에서 재정의 한 equals가 하위 클래스에서 사용하기에도 적당하다.
      + 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다.
    * 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때, 그리고 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때 재정의 해야한다.
    * equals는 동치 관계를 구현한다.
      + 반사성 : 모든 객체는 자기 자신과 같아야 한다.
        - null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
      + 대치성 : 두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다는 것이다.
        - null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
        - equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
      + 추이성 : 첫 번째 객체가 두 번째 객체와 같고, 두 번째 객체와 세 번째 객체와 같다면 세 번째 객체도 같아야 한다는 것이다.
        - null이 아닌 참조 x, y, z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
        - 객체 생성가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법이 없다.
        - 리스코프 대체 원칙(LSP)은 어떤 자료형의 중요한 속성은 하위 자료형에도 그대로 유지되어서, 그 자료형을 위한 메서드는 하위 자료형에도 잘 동작해야 한다는 원칙이다.
      + 일관성 : 일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 되어야 한다는 것이다.
        - null 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.
        - 변경 가능 여부에 상관없이, 신뢰성이 보장되는 않는 자원들을 비교하는 equals를 구현하는 것은 삼가라.
      + null에 대한 비 동치성 : 모든 객체는 null과 동치 관계에 있지 않는다.
        - null 이 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.
    * 훌륭한 equals 메서드를 구현하기 위해 따라야 할 지침
      1. == 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라.
      2. instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라.
      3. equals의 인자를 정확한 자료형으로 변환하라.
      4. "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.
      5. equals메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
      + equals를 구현할 때는 hashCode도 재정의하라.
      + 너무 머리 쓰지 마라.
        - 일반적으로 보면 앨리어싱까지 고려한 동치성 검사는 바람직하지 않다.
      + equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라.
  - 규칙 9 : equals를 재정의할 떄는 반드시 hashCode도 재정의하라
    * equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야한다.
      + 그렇지 않으면 Object.hashCode의 일반규약을 어기게 되므로, HashMap, HashTable같은 해시(hash)기반 컬렉션과 함께 사용하면 오동작하게 된다.
    * hashCode를 재정의하지 않으면 위반되는 핵심규약은 두 번째다. 같은 객체는 같은 해시코드 값을 가져야 한다는 규약이 위반되는 것이다.
    * 가장 끔찍한 형태의 해시 함수, 절대로 이렇게 구현하지 말 것
      + @override public int hashCode(){ return 42; }
    * 이상적인 해시 함수는 서로 다른 객체들을 모든 가능한 해시 값에 균등하게 배분해야 한다.
    * 주의할 것은, 성능을 개선하려고 객체의 중요 부분을 해시코드 계산 과정에서 생략하면 안 된다는 것이다.

  - 규칙 10 : toString은 항상 재정의하라
    * toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.
    * toString 메서드를 재정의하면 해당 객체만 해택을 보는 것이 아니라 해당 객체에 대한 참조를 유지하는 객체들, 특히 컬렉션까지 혜택을 본다.
    * 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다.
    * toString이 반환하는 문자열의 형식을 문서에 명시하면, 표준적이고 분명하며 사람이 읽기 쉬운 객체 표현법 구실을 한다는 장점이 있다.
    * toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.
    * 문자열 형식을 명시하건 그렇지 않건 간에, toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 하라.
  - 규칙 11 : clone을 재정의할 때는 신중하라.
    * Cloneable은 어떤 객체가 복제(clone)을 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인 인터페이스다.
    * 인터페이스에는 clone 메서드가 없으며, Object의 Clone 메서드는 protected로 선언되어 있다는 것이다.
      + 리플렉션을 사용하지 않고는 Cloneable을 구현한 객체라 해도 clone 메서드를 호출할 방법이 없다.
    * 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.
    * 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다.
    * 공변 반환형(covariant return type)
      + 재정의 메서드(overriding method)의 반환값 자료형은 재정의 되는 메서드의 반환값 자료형의 하위 클래스가 될 수 있다.  
      + 덕분에 재정의 메서드는 반환될 객체에 대한 더 많은 정보를 제공할 수 있고, 클라이언트는 형 변환을 하지 않아도 된다.
    * 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라.
    * 사실상 clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다.
    * 배열에 clone을 호출하면 반환되는 배열의 컴파일 시점(compile-time) 자료형은 복제 대상 배열의 자료형과 같다.
    * clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다.
    * 꼭 필요한 경우가 아니라면 객체를 복사할 대안을 제공하거나, 아예 복제 기능을 제공하지 않는 것이 낫다.
    * 객체 복제를 지원하는 좋은 방법은, 복사 생성자(copy constructor)나 복사 팩터리(copy factory)를 제공하는 것이다.

  - 규칙 12 : comparable 구현을 고려하라.
    * Comparable 인터페이스를 구현하는 클래스의 객체들은 자연적 순서(natural ordering)를 갖게 된다.
    * compareTo 메서드의 일반 규약은 equals와 비슷하다.
    * 객체참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 그대로 유지되어야 한다.
    * 첫 번째 객체가 두 번째 객체보다 크고 두 번쨰 객체가 세 번째 객체보다 클 경우 첫 번째 객체는 반드시 세 번째보다 커야 한다는 사실을 표현한다.
    * compareTo를 통한 동치성 검사 결과는 일반적으로 equals 메서드 실행 결과와 같아야 한다는 것은 강력한 권고사항이다.
