Effective Java 2/E - 조슈아 블로크
=============================

> 도서 : Effective Java 2/E
> 저자 : 조슈아 블로크

> 서론
  - 코드는 복사하기 보단 재사용 해야한다.
  - 모듈 간 의존성은 가능한 한 줄여야 한다.
  - 자바는 네 가지 유형의 자료형을 지원한다.
    * interface(annotation 포함)
    * class(enum 포함)
    * array
    * primitive
  - 클래스로 만든 개체(instance)와 배열은 객체(Object)다.
  - 기본 자료형 값들은 객체가 아니다.
  - 메서드의 시그니처는 그 이름과 형식 인자 자료형들로 구성된다.
  - 시그니처에는 메서드 반환값 자료형(return type)은 포함되지 않는다.
  - 공객API라는 용어는 단순히 API라고도 하는데, 프로그래머들이 클래스, 인터페이스, 패키지를 사용할 때 이용하는 클래스, 인터페이스, 생성자, 멤버, 그리고 직렬화 형식(serialized from)을 가리키는 말이다.
    * 줄임말로 interface라고도 한다.

### 객체의 생성과 삭제
  - 규칙 1 : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.
    * 클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다.
    * 장점
      + 생성자와는 달리 팩터리 메서드에는 이름이 있다.
      + 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시해 놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
        - 정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. (객체 통제 클래스)
        - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있고, 객체생성이 불가능한 클래스를 만들 수도 있다. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
      + 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
        - 반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
        - 인터페이스 기반 프레임워크 구현에 적합하다. 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.
        - 인터페이스 기반 프레임워크 기법 덕에 간단해진 것은 단순히 API의 규모가 아니며, 오히려 '개념상의 무게감'이다.
        - 정적팩터리 메서드가 반환하는 객체의 클래스는 정적 팩터리 메서드가 정의된 클래스의 코드가 작성되는 순간에 존재하지 않아도 무방하다.
        - 서비스 제공자 프레임워크는 세 가지의 핵심 컴포넌트로 구성된다.
          1. 서비스 인터페이스
          2. 제공자 등록 API
          3. 서비스 접근 API
          4. 서비스 제공자 인터페이스(option)
      + 형인자 자료형(parameterized type)객체를 만들 때 편하다는 점이다.
        - 자료형 유추 : 정적팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
    * 단점
      + public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.
        - 자바의 컬렉션 프레임워크에 포함된 기본 구현 클래스들의 하위 클래스는 만들 수 없다.
      + 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.
        - 클래스나 인터페이스 주석을 통해 정적팩터리 메서드임을 널리 알리거나, 정적 팩터리 메서드 이름을 지을 때 조심하는 수밖에 없다.
        - 자주 쓰는 이름
          1. valueOf
          2. of
          3. getInstance
          4. newInstance
          5. newType
    * 요약
      - 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다.
      - 정적 팩터리 메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야한다.

  - 규칙 2 : 생성자 인자가 많을 때는 builder패턴 적용을 고려해라.
    * 선택적인자가 많은 상황에서 사용할 수 있는 패턴
      + 점층적 생성자 패턴
        - 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로, 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의가 끝난다.
        - 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.
      + 자바빈 패턴
        - 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수뿐 아니라 선택적 필드의 값들까지 채우는 것이다 .
        - 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 꺠질수 있다.
      + 빌더 패턴
        - 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만든다.
        - 그런다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.
        - Ada나 Python같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
        - 빌더 객체는 여러개의 varargs인자를 받을 수 있는 장점이 있다.
        - 빌더 패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 우 있다.
        - 인자가 설정된 빌더는 훌륭한 추상적 팩터리다.
        - Class.newInstance는 컴파일 시점에 예외 검사가 가능해야한다는 규칙을 깨뜨린다.
        - 객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 단점이 있다.
    * 요약
      - 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유리하다.
