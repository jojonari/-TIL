Effective Java 2/E - 조슈아 블로크
=============================

> 도서 : Effective Java 2/E
> 저자 : 조슈아 블로크

> 서론
  - 코드는 복사하기 보단 재사용 해야한다.
  - 모듈 간 의존성은 가능한 한 줄여야 한다.
  - 자바는 네 가지 유형의 자료형을 지원한다.
    * interface(annotation 포함)
    * class(enum 포함)
    * array
    * primitive
  - 클래스로 만든 개체(instance)와 배열은 객체(Object)다.
  - 기본 자료형 값들은 객체가 아니다.
  - 메서드의 시그니처는 그 이름과 형식 인자 자료형들로 구성된다.
  - 시그니처에는 메서드 반환값 자료형(return type)은 포함되지 않는다.
  - 공객API라는 용어는 단순히 API라고도 하는데, 프로그래머들이 클래스, 인터페이스, 패키지를 사용할 때 이용하는 클래스, 인터페이스, 생성자, 멤버, 그리고 직렬화 형식(serialized from)을 가리키는 말이다.
    * 줄임말로 interface라고도 한다.

### 객체의 생성과 삭제
  - 규칙 1 : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.
    * 클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다.
    * 장점
      + 생성자와는 달리 팩터리 메서드에는 이름이 있다.
      + 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시해 놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
        - 정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. (객체 통제 클래스)
        - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있고, 객체생성이 불가능한 클래스를 만들 수도 있다. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
      + 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
        - 반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
        - 인터페이스 기반 프레임워크 구현에 적합하다. 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.
        - 인터페이스 기반 프레임워크 기법 덕에 간단해진 것은 단순히 API의 규모가 아니며, 오히려 '개념상의 무게감'이다.
        - 정적팩터리 메서드가 반환하는 객체의 클래스는 정적 팩터리 메서드가 정의된 클래스의 코드가 작성되는 순간에 존재하지 않아도 무방하다.
        - 서비스 제공자 프레임워크는 세 가지의 핵심 컴포넌트로 구성된다.
          1. 서비스 인터페이스
          2. 제공자 등록 API
          3. 서비스 접근 API
          4. 서비스 제공자 인터페이스(option)
      + 형인자 자료형(parameterized type)객체를 만들 때 편하다는 점이다.
        - 자료형 유추 : 정적팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
    * 단점
      + public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.
        - 자바의 컬렉션 프레임워크에 포함된 기본 구현 클래스들의 하위 클래스는 만들 수 없다.
      + 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.
        - 클래스나 인터페이스 주석을 통해 정적팩터리 메서드임을 널리 알리거나, 정적 팩터리 메서드 이름을 지을 때 조심하는 수밖에 없다.
        - 자주 쓰는 이름
          1. valueOf
          2. of
          3. getInstance
          4. newInstance
          5. newType
    * 요약
      - 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다.
      - 정적 팩터리 메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야한다.

  - 규칙 2 : 생성자 인자가 많을 때는 builder패턴 적용을 고려해라.
    * 선택적인자가 많은 상황에서 사용할 수 있는 패턴
      + 점층적 생성자 패턴
        - 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로, 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의가 끝난다.
        - 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.
      + 자바빈 패턴
        - 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수뿐 아니라 선택적 필드의 값들까지 채우는 것이다 .
        - 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 꺠질수 있다.
      + 빌더 패턴
        - 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만든다.
        - 그런다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.
        - Ada나 Python같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
        - 빌더 객체는 여러개의 varargs인자를 받을 수 있는 장점이 있다.
        - 빌더 패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 우 있다.
        - 인자가 설정된 빌더는 훌륭한 추상적 팩터리다.
        - Class.newInstance는 컴파일 시점에 예외 검사가 가능해야한다는 규칙을 깨뜨린다.
        - 객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 단점이 있다.
    * 요약
      - 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유리하다.

  - 규칙 3 : private 생성자나 enum자료형은 싱글턴 패턴을 따르도록 설계하라.
    * 싱글턴은 객체를 하나만 만들 수 있는 클래스다.
    * 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기 어려워질 수가 있다.
      + 싱글턴이 어떤 인터페이스를 구현하는 것이 아니면 가짜 구현으로 대체할 수 없기 때문이다.
    * 싱글턴 객체 생성 방법
      + private로 선언하고 싱글턴 객체는 정적 멤버를 통해 이용한다.
      + public으로 선언된 정적 팩터리 메서드를 이용하는 것
      + 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.

  - 규칙 4 : 객체 생성을 막을 때는 private 생성자를 사용하라.
    * 정적메서드나 필드만 모은 클래스를 이용하고 싶을때
    * 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해봤자 소용없다.
      + 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
    * private 생성자를 클래스에 넣어서 객체생성을 방지 할 수 있다.
      + 이렇게 하면 하위 클래스도 만들수 없다.
      + 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 떄문이다.
  - 규칙 5 : 불필요한 객체는 만들지 말라.
    * 기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다.
    * 객체를 재사용하는 프로그램은 더 빠르고 우아하다.
    * 변경 불가능한 객체는 언제나 재사용할 수 있다.
    * 생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능한 클래스의 경우 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다.
    * 자동 객체화(autoboxing)  
      + 프로그래머들이 자바의 기본자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해준다.
      + 둘간의 변환은 자동으로 이뤄진다.
      + 의미적 차이는 희미해졌지만, 성능차이는 무시하기 어렵다.
    * long과 Long
      + long : 기본 자료형
      + Long : 객체 표현형
    * 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않다록 유의하라.
    * 직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.
    * 방어적 복사 : '새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라'

  - 규칙 6 : 유효기간이 지난 객체 참조는 폐기하라.
    * 만기 참조 : 다시 이용되지 않을 참조
    * 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수문제(널리 알려진 용어로는 '의도치 않은 객체보유'라고 한다.)는 찾아내기 어렵다.
    * 쓸 일 없는 객체 참조는 무조건 null로 만드는 것으로 해결 한다.
    * 객체 참조를 null처리 하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.
    * 변소를 정의할 때 그 유효범위를 최대한 좁게 만들면 자연스럽게 해결된다.
    * 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다.
    * 캐시도 메모리 누수가 흔히 발생하는 장소다.
    * 리스너 등의 역호출자(call back)에서도 메모리누수가 발생한다.
      + 역호출자에 대한 약한 참조만 저장한는 것으로 해결한다.
