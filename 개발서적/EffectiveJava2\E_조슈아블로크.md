Effective Java 2/E - 조슈아 블로크
=============================

> 도서 : Effective Java 2/E
> 저자 : 조슈아 블로크

### 서론
  - 코드는 복사하기 보단 재사용 해야한다.
  - 모듈 간 의존성은 가능한 한 줄여야 한다.
  - 자바는 네 가지 유형의 자료형을 지원한다.
    * interface(annotation 포함)
    * class(enum 포함)
    * array
    * primitive
  - 클래스로 만든 개체(instance)와 배열은 객체(Object)다.
  - 기본 자료형 값들은 객체가 아니다.
  - 메서드의 시그니처는 그 이름과 형식 인자 자료형들로 구성된다.
  - 시그니처에는 메서드 반환값 자료형(return type)은 포함되지 않는다.
  - 공객API라는 용어는 단순히 API라고도 하는데, 프로그래머들이 클래스, 인터페이스, 패키지를 사용할 때 이용하는 클래스, 인터페이스, 생성자, 멤버, 그리고 직렬화 형식(serialized from)을 가리키는 말이다.
    * 줄임말로 interface라고도 한다.

### 객체의 생성과 삭제
  - 규칙 1 : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.
    * 클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다.
    * 장점
      + 생성자와는 달리 팩터리 메서드에는 이름이 있다.
      + 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시해 놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
        - 정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. (객체 통제 클래스)
        - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있고, 객체생성이 불가능한 클래스를 만들 수도 있다. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
      + 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
        - 반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
        - 인터페이스 기반 프레임워크 구현에 적합하다. 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.
        - 인터페이스 기반 프레임워크 기법 덕에 간단해진 것은 단순히 API의 규모가 아니며, 오히려 '개념상의 무게감'이다.
        - 정적팩터리 메서드가 반환하는 객체의 클래스는 정적 팩터리 메서드가 정의된 클래스의 코드가 작성되는 순간에 존재하지 않아도 무방하다.
        - 서비스 제공자 프레임워크는 세 가지의 핵심 컴포넌트로 구성된다.
          1. 서비스 인터페이스
          2. 제공자 등록 API
          3. 서비스 접근 API
          4. 서비스 제공자 인터페이스(option)
      + 형인자 자료형(parameterized type)객체를 만들 때 편하다는 점이다.
        - 자료형 유추 : 정적팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
    * 단점
      + public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.
        - 자바의 컬렉션 프레임워크에 포함된 기본 구현 클래스들의 하위 클래스는 만들 수 없다.
      + 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.
        - 클래스나 인터페이스 주석을 통해 정적팩터리 메서드임을 널리 알리거나, 정적 팩터리 메서드 이름을 지을 때 조심하는 수밖에 없다.
        - 자주 쓰는 이름
          1. valueOf
          2. of
          3. getInstance
          4. newInstance
          5. newType
    * 요약
      - 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다.
      - 정적 팩터리 메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야한다.

  - 규칙 2 : 생성자 인자가 많을 때는 builder패턴 적용을 고려해라.
    * 선택적인자가 많은 상황에서 사용할 수 있는 패턴
      + 점층적 생성자 패턴
        - 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로, 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의가 끝난다.
        - 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.
      + 자바빈 패턴
        - 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수뿐 아니라 선택적 필드의 값들까지 채우는 것이다 .
        - 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 꺠질수 있다.
      + 빌더 패턴
        - 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만든다.
        - 그런다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.
        - Ada나 Python같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
        - 빌더 객체는 여러개의 varargs인자를 받을 수 있는 장점이 있다.
        - 빌더 패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 우 있다.
        - 인자가 설정된 빌더는 훌륭한 추상적 팩터리다.
        - Class.newInstance는 컴파일 시점에 예외 검사가 가능해야한다는 규칙을 깨뜨린다.
        - 객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 단점이 있다.
    * 요약
      - 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유리하다.

  - 규칙 3 : private 생성자나 enum자료형은 싱글턴 패턴을 따르도록 설계하라.
    * 싱글턴은 객체를 하나만 만들 수 있는 클래스다.
    * 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기 어려워질 수가 있다.
      + 싱글턴이 어떤 인터페이스를 구현하는 것이 아니면 가짜 구현으로 대체할 수 없기 때문이다.
    * 싱글턴 객체 생성 방법
      + private로 선언하고 싱글턴 객체는 정적 멤버를 통해 이용한다.
      + public으로 선언된 정적 팩터리 메서드를 이용하는 것
      + 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.

  - 규칙 4 : 객체 생성을 막을 때는 private 생성자를 사용하라.
    * 정적메서드나 필드만 모은 클래스를 이용하고 싶을때
    * 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해봤자 소용없다.
      + 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
    * private 생성자를 클래스에 넣어서 객체생성을 방지 할 수 있다.
      + 이렇게 하면 하위 클래스도 만들수 없다.
      + 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 떄문이다.
  - 규칙 5 : 불필요한 객체는 만들지 말라.
    * 기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다.
    * 객체를 재사용하는 프로그램은 더 빠르고 우아하다.
    * 변경 불가능한 객체는 언제나 재사용할 수 있다.
    * 생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능한 클래스의 경우 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다.
    * 자동 객체화(autoboxing)  
      + 프로그래머들이 자바의 기본자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해준다.
      + 둘간의 변환은 자동으로 이뤄진다.
      + 의미적 차이는 희미해졌지만, 성능차이는 무시하기 어렵다.
    * long과 Long
      + long : 기본 자료형
      + Long : 객체 표현형
    * 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않다록 유의하라.
    * 직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.
    * 방어적 복사 : '새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라'

  - 규칙 6 : 유효기간이 지난 객체 참조는 폐기하라.
    * 만기 참조 : 다시 이용되지 않을 참조
    * 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수문제(널리 알려진 용어로는 '의도치 않은 객체보유'라고 한다.)는 찾아내기 어렵다.
    * 쓸 일 없는 객체 참조는 무조건 null로 만드는 것으로 해결 한다.
    * 객체 참조를 null처리 하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.
    * 변소를 정의할 때 그 유효범위를 최대한 좁게 만들면 자연스럽게 해결된다.
    * 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다.
    * 캐시도 메모리 누수가 흔히 발생하는 장소다.
    * 리스너 등의 역호출자(call back)에서도 메모리누수가 발생한다.
      + 역호출자에 대한 약한 참조만 저장한는 것으로 해결한다.
  - 규칙 7 : 종료자 사용을 피하라
    * 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
    * 자바에서는 더 이상 참조되지 않는 객체에 할당된 공간을 쓰레기 수집기가 알아서 반환하므로 프로그래머 입장에서 특별히 할 일이 없다.
    * 자바는 보통 try-finally 블록이 메모리 이외의 자원을 반환하는데 사용된다.
    * 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다.
    * JVM은 종료자를 천천히 실행하므로 열린 상태의 파일이 많이 남아있을 수 있다.
    * 더딘 실행(tardy finalization) : 클래스에 종료자를 붙여 놓으면, 드믄 일이지만 객체 메모리 반환이 지연될 수도 있다.
    * 지속성이 보장되어야 하는 중요 상태 정보(critical persistent)는 종료자로 갱신하면 안 된다.
    * 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
    * 명시적인 종료 메서드를 하나 정의하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록하라.
      + 한 가지 명심할 것은 종료여부를 객체 안에 보관해야 한다는 것
      + 유효하지 않은 객체임을 표시하는 private필드를 하나두고, 모든 메서드 맨앞에 해당 필드를 검사하는 코드를 두어, 이미 종료된 객체에 메서드를 호출하면 IllegalStateException이 던져지도록 해야한다는 것이다.
    * 명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다.
      + 객체종료를 보장하기 위해서
    * 종료자 사용이 적합한 두 번째 경우는 네이티브 피어와 연결된 객체를 다룰때다.
      + 네이티브 피어는 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 네이티브 객체를 말한다.
    * 하위 클래스에서 상위 클래스 종료자를 재정의(override)하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다.
    * 자원 반환에 대한 최종적 안전장치를 구현하거나, 그다지 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말라는 것이다.
      + 굳이 종료자를 사용해야 하는 드문 상황에 처했다면 super.finalize 호출을 잊지 말자.

### 모든 객체의 공통 메서드
  - Object는 객체 생성이 가능한 클래스(concrete class)이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다.
  - 규칙 8 : equals를 재정의할 떄는 일반 규약을 따르라
    * equals를 재정의하지 않기 위한 조건
      + 각각의 객체가 고유하다.
      + 클래스에 "논리적 동일성(logical equality)" 검사 방법이 있건 없건 상관없다.
      + 상위 클래스에서 재정의 한 equals가 하위 클래스에서 사용하기에도 적당하다.
      + 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다.
    * 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때, 그리고 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때 재정의 해야한다.
    * equals는 동치 관계를 구현한다.
      + 반사성 : 모든 객체는 자기 자신과 같아야 한다.
        - null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
      + 대치성 : 두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다는 것이다.
        - null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
        - equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
      + 추이성 : 첫 번째 객체가 두 번째 객체와 같고, 두 번째 객체와 세 번째 객체와 같다면 세 번째 객체도 같아야 한다는 것이다.
        - null이 아닌 참조 x, y, z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
        - 객체 생성가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법이 없다.
        - 리스코프 대체 원칙(LSP)은 어떤 자료형의 중요한 속성은 하위 자료형에도 그대로 유지되어서, 그 자료형을 위한 메서드는 하위 자료형에도 잘 동작해야 한다는 원칙이다.
      + 일관성 : 일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 되어야 한다는 것이다.
        - null 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.
        - 변경 가능 여부에 상관없이, 신뢰성이 보장되는 않는 자원들을 비교하는 equals를 구현하는 것은 삼가라.
      + null에 대한 비 동치성 : 모든 객체는 null과 동치 관계에 있지 않는다.
        - null 이 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.
    * 훌륭한 equals 메서드를 구현하기 위해 따라야 할 지침
      1. == 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라.
      2. instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라.
      3. equals의 인자를 정확한 자료형으로 변환하라.
      4. "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.
      5. equals메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
      + equals를 구현할 때는 hashCode도 재정의하라.
      + 너무 머리 쓰지 마라.
        - 일반적으로 보면 앨리어싱까지 고려한 동치성 검사는 바람직하지 않다.
      + equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라.
  - 규칙 9 : equals를 재정의할 떄는 반드시 hashCode도 재정의하라
    * equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야한다.
      + 그렇지 않으면 Object.hashCode의 일반규약을 어기게 되므로, HashMap, HashTable같은 해시(hash)기반 컬렉션과 함께 사용하면 오동작하게 된다.
    * hashCode를 재정의하지 않으면 위반되는 핵심규약은 두 번째다. 같은 객체는 같은 해시코드 값을 가져야 한다는 규약이 위반되는 것이다.
    * 가장 끔찍한 형태의 해시 함수, 절대로 이렇게 구현하지 말 것
      + @override public int hashCode(){ return 42; }
    * 이상적인 해시 함수는 서로 다른 객체들을 모든 가능한 해시 값에 균등하게 배분해야 한다.
    * 주의할 것은, 성능을 개선하려고 객체의 중요 부분을 해시코드 계산 과정에서 생략하면 안 된다는 것이다.

  - 규칙 10 : toString은 항상 재정의하라
    * toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.
    * toString 메서드를 재정의하면 해당 객체만 해택을 보는 것이 아니라 해당 객체에 대한 참조를 유지하는 객체들, 특히 컬렉션까지 혜택을 본다.
    * 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다.
    * toString이 반환하는 문자열의 형식을 문서에 명시하면, 표준적이고 분명하며 사람이 읽기 쉬운 객체 표현법 구실을 한다는 장점이 있다.
    * toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.
    * 문자열 형식을 명시하건 그렇지 않건 간에, toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 하라.
  - 규칙 11 : clone을 재정의할 때는 신중하라.
    * Cloneable은 어떤 객체가 복제(clone)을 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인 인터페이스다.
    * 인터페이스에는 clone 메서드가 없으며, Object의 Clone 메서드는 protected로 선언되어 있다는 것이다.
      + 리플렉션을 사용하지 않고는 Cloneable을 구현한 객체라 해도 clone 메서드를 호출할 방법이 없다.
    * 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.
    * 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다.
    * 공변 반환형(covariant return type)
      + 재정의 메서드(overriding method)의 반환값 자료형은 재정의 되는 메서드의 반환값 자료형의 하위 클래스가 될 수 있다.  
      + 덕분에 재정의 메서드는 반환될 객체에 대한 더 많은 정보를 제공할 수 있고, 클라이언트는 형 변환을 하지 않아도 된다.
    * 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라.
    * 사실상 clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다.
    * 배열에 clone을 호출하면 반환되는 배열의 컴파일 시점(compile-time) 자료형은 복제 대상 배열의 자료형과 같다.
    * clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다.
    * 꼭 필요한 경우가 아니라면 객체를 복사할 대안을 제공하거나, 아예 복제 기능을 제공하지 않는 것이 낫다.
    * 객체 복제를 지원하는 좋은 방법은, 복사 생성자(copy constructor)나 복사 팩터리(copy factory)를 제공하는 것이다.

  - 규칙 12 : comparable 구현을 고려하라.
    * Comparable 인터페이스를 구현하는 클래스의 객체들은 자연적 순서(natural ordering)를 갖게 된다.
    * compareTo 메서드의 일반 규약은 equals와 비슷하다.
    * 객체참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 그대로 유지되어야 한다.
    * 첫 번째 객체가 두 번째 객체보다 크고 두 번쨰 객체가 세 번째 객체보다 클 경우 첫 번째 객체는 반드시 세 번째보다 커야 한다는 사실을 표현한다.
    * compareTo를 통한 동치성 검사 결과는 일반적으로 equals 메서드 실행 결과와 같아야 한다는 것은 강력한 권고사항이다.
### 클래스와 인터페이스
  - 클래스와 인터페이스는 자바 프로그래밍 언어의 핵심적인 부분으로서, 추상화의 기본 단위다.

  - 규칙 13 : 클래스와 멤버의 접근 권한은 최소화하라.
    * 세부구현사항은 API 뒤쪽으로 감추고 모듈들은 이 API를 통해서만 서로 통신하며, 각자 내부적으로 무슨 짓을 하는지는 신경 쓰지 않는다.
      + 정보은닉(information hiding) 또는 캡슐화(encapsulation)이라고 한다.
    * 정보 은닉 원칙이 좋은 성능을 자동적으로 보장하는 것은 아니지만, 효과적인 성능 튜닝을 가능하게 하는것은 사실이다.
    * 접근 제어 메커니즘은 클래스와 인터페이스, 그리고 그 멤버들의 접근 권한을 규정한다.
    * 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어라.
      + 개발중인 소프트웨어의 정상적인 동작을 보증하는 한도 내에서 가장 낮은 접근 권한을 설정하라는 것이다.
      + 최상위 레벨 클래스나 인터페이스는 가능한 package-private로 선언해야 한다.
    * 접근 권한 증가순서
      + private : 이렇게 선언된 멤버는 선언된 초상위 레벨 클래스 내부에서만 접근 가능하다.
      + package-private :  이렇게 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한 으로 알려져있는데, 멤버를 선언할 때 아무런 접근 권한 수정자도 붙이지 않으면, 이권한 이 주어진다.
      + protected : 이렇게 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있다. 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용가능하다.
      + public : 이렇게 선언된 멤버는 어디서도 사용이 가능하다.
    * 객체 필드(instance field)는 절대로 public으로 선언하면 안된다.
      + 필드가 변경될 때 특정한 동작이 실행 되도록 할수도 없으므로, 변경가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않다.
    * 길이가 0이 아닌 배열은 언제나 변경 가능하므로 public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자를 정의하면 안된다.

  - 규칙 14 : public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라.
    * 선언된 패키지 ㅂㄲ에서도 사용 가능한 클래스에는 접근자 메서드를 제공하라.
    * package-private 클래스나 private 중첩 클래스는 데이터필드를 공개하더라도 잘못이라 말할 수 없다.

  - 규칙 15 : 변겨 가능성을 최소화 하라.
    * 변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스다.
    * 변경 불가능 클래스는 변경 가능 클래스보다 설계하기 쉽고 구현하기 쉬우며, 사용하기도 쉽다. 오류가능성도 적고, 더 안전하다.
    * 변경 불가능 클래스의 다섯 규칙
      1. 객체 상태를 변경하늠 메서드(수정자 메서드 등)를 제공하지 않는다.
      2. 계승할 수 없도록 한다.
        + 보통 final로 선언하면 된다.
      3. 모든 필드를 final로 선언한다.
      4. 모든 필드를 private로 선언한다.
      5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.
        + 생성자나 접근자, readObject메서드 안에서는 방어적 복사본을 만들어야 한다.
    * 변경 불가능 객체는 단순하다.
      + 생성될 때 부여된 한 가지 상태만 갖는다.
    * 변경 불가능 객체는 스레드에 안전 할 수밖에 없다.
      + 어떤 동기화도 필요 없으며, 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없다.
    * 변경 불가능한 객체는 자유롭게 공유할 수 있다.
    * 변경 불가능한 객체는 그 내부도 공유할 수 있다.
    * 변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다.
    * 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.
      + 객체 생성 비용이 높을 가능성이 있다.
    * 모든 get메서드마다 그에 대응하는 set메서드를 두는 것은 피해야 한다.
      + 변경 가능한 클래스로 만들 타당한 이유가 없다면, 반드시 변경 불가능 클래스로 만들어야 한다.
    * 변경 불가능 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라.
    * 특별한 이유가 없다면 모든 필드는 final로 선언하라.
    * "재 초기화(reinitalize)"메서드도 제공하지 마라. 코드 복잡성만 늘어나고, 성능 향상에 도움 되는 경우는 거의 없다.

  - 규칙 16 : 계승하는 대신 구성하라.
    * 계승은 상위 클래스와 하위클래스 구현을 같은 프로그래머가 통제하는 단일 패키지 안에서 사용하면 안전하다.
    * 한 클래스가 다른 클래스를 'extends'하는 것을 계승이라고 한다.
      + 어떤 클래스가 다른 인터페이스를 'implements'하거나 어떤 인터페이스가 다른 인터페이스를 'extends'하는 경우에는 적용되지 않는다.
    * 메서드 호출과 달리, 계승은 캡슐 원칙을 위반한다.
      + 하위클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수밖에 없다.
    * 기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 private 필드를 하나 두어 문제를 해결하는 설계 기법을 구성(composition)이라고 부른다.
      + 기존클래스가 새클래스의 일부가 된다.
    * 새로운 클래스에 포함된 각각의 메서드는 기존 클래스에 있는 메서드 가운데 필요한 것을 호출해서 그 결과를 반환하는 기법을 전달이라고 하고, 전달 기법을 사용해 구현된 메서드를 전달 메서드라고 부른다.
    * 계승은 하위 클래스가 상위 클래스의 하위 자료형(subtype)이 확실한 경우에만 바람직하다.
    * 요약
      + 계승은 강력한 도구이지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다는 것이다. 상위 클래스와 하위 클래스 사이에 IS-A 관계가 있을 때만 사용하는 것이 좋다. 설사 IS-A 관계가 성립해도, 하위 클래스가 상위 클래스와 다른 패키지에 있거나 계승을 고려해 만들어진 상위클래스가 아니라며, 하위 클래스는 깨지기 쉽다. 이런 문제를 피하려면 구성과 전달 기법을 사용하는 것이좋다. 데코레이션 패턴 구현에 적당한 인터페이스가 있다면 더욱 그렇다. 데코레이션 클래스는 하위 클래스보다 견고할 뿐 아니라, 더 강력하다.

  - 규칙 17 : 계승을 위한 설계 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라.
    * 메서드를 재정의하면 무슨 일이 생기는지 정확하게 문서로 남겨야 한다. 다시말해, 재정의 가능 메서드를 내부적으로 어떻게 사용하는지(self-use) 반드시 문서에 남겨라.
    * 클래스 내부 동작에 개입할 수 있는 훅(hooks)을 신중하게 고른 protected 메서드 형태로 제공해야 한다.
    * 계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다.
    * 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출 해서는 안 된다는 것이다.
      + clone이나 readObject메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 주의해야 한다는 것이다.
    * 계승을 위해 클래스를 설계하면 클래스에 상당한 제약이 가해진다.
    * 변경불가능 클래스라면 계승은 배재해야한다.
    * 계승에 맞도록 설계하고 문서화하지 않은 클래스에 대한 하위 클래스는 만들지 않는다.
    * 클래스 생성을 금지하는 방법
      + 클래스를 final로 선언하는 것
      + 대안 : 모든 생성자를 private이나 package-private로 선언하고 생성자대신 public 정적 팩터리 메서드를 추가하는 것

  - 규칙 18 : 추상 클래스 대신 인터페이스를 사용하라.
    * 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.
    * 자바는 다중상속을 허용하지 않기 때문에, 추상 클래스를 사용하게 되면 자료형으로 사용하는 데 많은 제약이 발생하게 된다.
    * 인터페이스는 믹스인을 정의하는 데 이상적이다.
      + 믹스인은 클래스가 '주 자료형' 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.
    * 인터페이스는 비 계층적인 자료형 프레임워크를 만들수 있도록 한다.
    * 인터페이스를 사용하면 포장 클래스 숙어(wrapper class idiom)을 통해 안전하면서도 강력한 기능 개선이 가능하다.
      + 추상클래스를 사용해 자료형을 정의하면 프로그래머는 계승 이외의 수단을 사용할 수 없다.
      + 그렇게 해서 만든 클래스는 포장 클래스 보다 강력하지도 않고, 깨지기도 쉽다.
    * 추상 골격 구현 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합 할 수 있다.
    * 모의 가상 상속 : 골격 구현 클래스를 계씅하는 private 내부 클래스를 정의하고 인터페이스 메서드에 대한 호출은 해당 중첩 클래스 객체로 전달 하는 것이다.
    * 다양한 구현을 허용하는 자료형을 추상 클래스로 정의하면 인터페이스보다 나은 점이 한가지 있는데, 인터페이스보다는 추상 클래스가 발전 시키기 쉽다는 것이다.
    * 인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능하기 떄문이다.

  - 규칙 19 : 인터페이스는 자료형을 정의할 때만 사용하라.
    * 인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형 역할을 하게 된다.
    * 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.
    * 인터페이스는 자료형을 정의할 때만 사용해야 한다.
    * 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.

  - 규칙 20 : 태그 달린 클래스 대신 클래스 계층을 활용하라.
    * 태그 기반 클래스는 너저분한데다 오류 발생가능성이 높고, 효율적이지도 않다.
    * 태그 기반 클래스는 클래스 계층을 얼기설기 흉내 낸 것일 뿐이다.
    * 태그 기반 클래스를 클래스 계층으로 변환하려면, 먼저 태그 값에 따라 달리동작하는 메서드를 추상 메서드로 선언하는 추상 클래스를 정의해야 한다.
    * 클래스 계층의 또 다른 장점은 자료형 간의 자연스러운 계층 관계를 반영할 수 있어서 유연성이 높아지고 컴파일 시에 형 검사를 하기 용이하다는 것이다.
    * 태그 기반 클래스 사용은 피해야 한다. 클래스 안에 태그 필드를 명시적으로 두고 싶다는 생각이 든다면, 클래스 계층을 통해 태그를 제거할 방법이 없는지 생각해보기 바란다. 태그 필드가 있는 클래스를 만나게 된다면, 리펙터링을 통해 클래스 계층으로 변환할 방법은 없는지 고민해 보기 바란다.

  - 규칙 21 : 전략을 표현하고 싶을 때는 함수 객체를 사용하라.
    * 함수 객체의 주된 용도는 전략 패턴을 구현하는 것이다.
    * 자바로 이 패턴을 구현하기 위해서는 전략을 표현하는 인터페이스를 선언하고, 실행 가능 전략 클래스가 전부 해당 인터페이스를 구현하도록 해야 한다.
    * 실행 가능 전략이 한 번만 사용되는 경우에는 보통 그 전략을 익명 클래스 객체로 구현한다.
    * 반복적으로 사용된다면 private static멤버 클래스로 전햑을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하는 것이 바람직 하다.

  - 규칙 22 : 멤버 클래스는 가능하면 static으로 선언하라.
    * 중첩 클래스는 다른 클래스 안에 정의된 클래스다.
    * 중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용된다.
    * 중첩 클래스에는 네 가지 종류가 있다.
      + 정적 멤버 클래스
      + 비-정적 멤버 클래스
      + 익명 클래스
      + 지역 클래스
    * 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 떄는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스를 만들자.
    * 익명 클래스를 사용하는 데는 많은 계약이 있다.
      + 선언하는 순간에만 객체를 만들 수 있다.
    * 여러 인터페이스를 구현하는 익명 클래스는 선언할 수 없으며, 인터페이스를 구현하는 동시에 특정한 클래스를 계승하는 익명 클래스도 만들 수 없다.
    * 익명 클래스는 함수 객체를 정의할 때 널리 쓰인다.
    * 익명 클래스는 Runnable, Thread, TimerTask 객체 같은 프로세스 객체를 만드는 데도 널리 쓰인다.
      + 정적 팩터리 메서드 안에서도 많이 쓰인다.
    * 중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에 너무 길 경우에는 멤버 클래스로 정의하라.
    * 멤버 클래스의 객체 각각이 바깥 객체에 대한 참조를 가져야 하는 경우에는 비-정적 멤버 클래스로 만들라.
      + 그렇지 않은 경우에는 정적 멤버 클래스로 만들면 된다.
      + 중첩 클래스가 특정한 메서드에 속해야 하고, 오직 한곳에서만 객체를 생성하며, 해당 중첩클래스의 특성을 규정하는 자료형이 이미 있다면 익명 클래스로 만들라.
      + 그렇지 않을떄는 지역클래스로 만들면 된다.

  
