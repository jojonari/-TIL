Effective Java 2/E - 조슈아 블로크
=============================

> 도서 : Effective Java 2/E
> 저자 : 조슈아 블로크

### 서론
  - 코드는 복사하기 보단 재사용 해야한다.
  - 모듈 간 의존성은 가능한 한 줄여야 한다.
  - 자바는 네 가지 유형의 자료형을 지원한다.
    * interface(annotation 포함)
    * class(enum 포함)
    * array
    * primitive
  - 클래스로 만든 개체(instance)와 배열은 객체(Object)다.
  - 기본 자료형 값들은 객체가 아니다.
  - 메서드의 시그니처는 그 이름과 형식 인자 자료형들로 구성된다.
  - 시그니처에는 메서드 반환값 자료형(return type)은 포함되지 않는다.
  - 공객API라는 용어는 단순히 API라고도 하는데, 프로그래머들이 클래스, 인터페이스, 패키지를 사용할 때 이용하는 클래스, 인터페이스, 생성자, 멤버, 그리고 직렬화 형식(serialized from)을 가리키는 말이다.
    * 줄임말로 interface라고도 한다.

### 객체의 생성과 삭제
  - 규칙 1 : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.
    * 클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다.
    * 장점
      + 생성자와는 달리 팩터리 메서드에는 이름이 있다.
      + 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.
        - 변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시해 놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
        - 정적 팩터리 메서드를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. (객체 통제 클래스)
        - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있고, 객체생성이 불가능한 클래스를 만들 수도 있다. 변경이 불가능한 클래스의 경우 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
      + 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
        - 반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
        - 인터페이스 기반 프레임워크 구현에 적합하다. 인터페이스는 정적 팩터리 메서드의 반환값 자료형으로 이용된다.
        - 인터페이스 기반 프레임워크 기법 덕에 간단해진 것은 단순히 API의 규모가 아니며, 오히려 '개념상의 무게감'이다.
        - 정적팩터리 메서드가 반환하는 객체의 클래스는 정적 팩터리 메서드가 정의된 클래스의 코드가 작성되는 순간에 존재하지 않아도 무방하다.
        - 서비스 제공자 프레임워크는 세 가지의 핵심 컴포넌트로 구성된다.
          1. 서비스 인터페이스
          2. 제공자 등록 API
          3. 서비스 접근 API
          4. 서비스 제공자 인터페이스(option)
      + 형인자 자료형(parameterized type)객체를 만들 때 편하다는 점이다.
        - 자료형 유추 : 정적팩터리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할 수 있다.
    * 단점
      + public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.
        - 자바의 컬렉션 프레임워크에 포함된 기본 구현 클래스들의 하위 클래스는 만들 수 없다.
      + 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.
        - 클래스나 인터페이스 주석을 통해 정적팩터리 메서드임을 널리 알리거나, 정적 팩터리 메서드 이름을 지을 때 조심하는 수밖에 없다.
        - 자주 쓰는 이름
          1. valueOf
          2. of
          3. getInstance
          4. newInstance
          5. newType
    * 요약
      - 정적 팩터리 메서드와 public 생성자는 용도가 서로 다르며, 그 차이와 장단점을 이해하는 것이 중요하다.
      - 정적 팩터리 메서드가 효과적인 경우가 많으니, 정적 팩터리 메서드를 고려해 보지도 않고 무조건 public 생성자를 만드는 것은 삼가야한다.

  - 규칙 2 : 생성자 인자가 많을 때는 builder패턴 적용을 고려해라.
    * 선택적인자가 많은 상황에서 사용할 수 있는 패턴
      + 점층적 생성자 패턴
        - 필수 인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로, 생성자를 쌓아 올리듯 추가하는 것이다. 결국 모든 선택적 인자를 다 받는 생성자를 추가하면 정의가 끝난다.
        - 점층적 생성자 패턴은 잘 동작하지만 인자 수가 늘어나면 클라이언트 코드를 작성하기 어려워지고, 무엇보다 읽기 어려운 코드가 되고 만다.
      + 자바빈 패턴
        - 인자 없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수뿐 아니라 선택적 필드의 값들까지 채우는 것이다 .
        - 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 꺠질수 있다.
      + 빌더 패턴
        - 필요한 객체를 직접 생성하는 대신, 클라이언트는 먼저 필수 인자들을 생성자에 전부 전달하여 빌더 객체를 만든다.
        - 그런다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가해 나간다.
        - Ada나 Python같은 언어는 선택적 인자에 이름을 붙일 수 있도록 허용하는데 그것과 비슷한 코드를 작성할 수 있기 때문이다.
        - 빌더 객체는 여러개의 varargs인자를 받을 수 있는 장점이 있다.
        - 빌더 패턴은 유연하다. 하나의 빌더 객체로 여러 객체를 만들 우 있다.
        - 인자가 설정된 빌더는 훌륭한 추상적 팩터리다.
        - Class.newInstance는 컴파일 시점에 예외 검사가 가능해야한다는 규칙을 깨뜨린다.
        - 객체를 생성하려면 우선 빌더 객체를 생성해야 한다는 단점이 있다.
    * 요약
      - 빌더 패턴은 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때, 특히 대부분의 인자가 선택적 인자인 상황에 유리하다.

  - 규칙 3 : private 생성자나 enum자료형은 싱글턴 패턴을 따르도록 설계하라.
    * 싱글턴은 객체를 하나만 만들 수 있는 클래스다.
    * 클래스를 싱글턴으로 만들면 클라이언트를 테스트하기 어려워질 수가 있다.
      + 싱글턴이 어떤 인터페이스를 구현하는 것이 아니면 가짜 구현으로 대체할 수 없기 때문이다.
    * 싱글턴 객체 생성 방법
      + private로 선언하고 싱글턴 객체는 정적 멤버를 통해 이용한다.
      + public으로 선언된 정적 팩터리 메서드를 이용하는 것
      + 원소가 하나뿐인 enum 자료형이야말로 싱글턴을 구현하는 가장 좋은 방법이다.

  - 규칙 4 : 객체 생성을 막을 때는 private 생성자를 사용하라.
    * 정적메서드나 필드만 모은 클래스를 이용하고 싶을때
    * 객체를 만들 수 없도록 하려고 클래스를 abstract로 선언해봤자 소용없다.
      + 하위 클래스를 정의하는 순간 객체 생성이 가능해지기 때문이다.
    * private 생성자를 클래스에 넣어서 객체생성을 방지 할 수 있다.
      + 이렇게 하면 하위 클래스도 만들수 없다.
      + 모든 생성자는 상위 클래스의 생성자를 명시적으로든 아니면 묵시적으로든 호출할 수 있어야 하는데, 호출 가능한 생성자가 상위 클래스에 없기 떄문이다.
  - 규칙 5 : 불필요한 객체는 만들지 말라.
    * 기능적으로 동일한 객체는 필요할 때마다 만드는 것보다 재사용하는 편이 낫다.
    * 객체를 재사용하는 프로그램은 더 빠르고 우아하다.
    * 변경 불가능한 객체는 언제나 재사용할 수 있다.
    * 생성자와 정적 팩터리 메서드를 함께 제공하는 변경 불가능한 클래스의 경우 생성자 대신 정적 팩터리 메서드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다.
    * 자동 객체화(autoboxing)  
      + 프로그래머들이 자바의 기본자료형과 그 객체 표현형을 섞어 사용할 수 있도록 해준다.
      + 둘간의 변환은 자동으로 이뤄진다.
      + 의미적 차이는 희미해졌지만, 성능차이는 무시하기 어렵다.
    * long과 Long
      + long : 기본 자료형
      + Long : 객체 표현형
    * 객체 표현형 대신 기본 자료형을 사용하고, 생각지도 못한 자동 객체화가 발생하지 않다록 유의하라.
    * 직접 관리하는 객체 풀을 만들어 객체 생성을 피하는 기법은 객체 생성 비용이 극단적으로 높지 않다면 사용하지 않는 것이 좋다.
    * 방어적 복사 : '새로운 객체를 만들어야 한다면 기존 객체는 재사용하지 말라'

  - 규칙 6 : 유효기간이 지난 객체 참조는 폐기하라.
    * 만기 참조 : 다시 이용되지 않을 참조
    * 자동적으로 쓰레기 객체를 수집하는 언어에서 발생하는 메모리 누수문제(널리 알려진 용어로는 '의도치 않은 객체보유'라고 한다.)는 찾아내기 어렵다.
    * 쓸 일 없는 객체 참조는 무조건 null로 만드는 것으로 해결 한다.
    * 객체 참조를 null처리 하는 것은 규범이라기보단 예외적인 조치가 되어야 한다.
    * 변소를 정의할 때 그 유효범위를 최대한 좁게 만들면 자연스럽게 해결된다.
    * 자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다.
    * 캐시도 메모리 누수가 흔히 발생하는 장소다.
    * 리스너 등의 역호출자(call back)에서도 메모리누수가 발생한다.
      + 역호출자에 대한 약한 참조만 저장한는 것으로 해결한다.
  - 규칙 7 : 종료자 사용을 피하라
    * 종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.
    * 자바에서는 더 이상 참조되지 않는 객체에 할당된 공간을 쓰레기 수집기가 알아서 반환하므로 프로그래머 입장에서 특별히 할 일이 없다.
    * 자바는 보통 try-finally 블록이 메모리 이외의 자원을 반환하는데 사용된다.
    * 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다.
    * JVM은 종료자를 천천히 실행하므로 열린 상태의 파일이 많이 남아있을 수 있다.
    * 더딘 실행(tardy finalization) : 클래스에 종료자를 붙여 놓으면, 드믄 일이지만 객체 메모리 반환이 지연될 수도 있다.
    * 지속성이 보장되어야 하는 중요 상태 정보(critical persistent)는 종료자로 갱신하면 안 된다.
    * 종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.
    * 명시적인 종료 메서드를 하나 정의하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메서드를 호출하도록하라.
      + 한 가지 명심할 것은 종료여부를 객체 안에 보관해야 한다는 것
      + 유효하지 않은 객체임을 표시하는 private필드를 하나두고, 모든 메서드 맨앞에 해당 필드를 검사하는 코드를 두어, 이미 종료된 객체에 메서드를 호출하면 IllegalStateException이 던져지도록 해야한다는 것이다.
    * 명시적 종료 메서드는 보통 try-finally 문과 함께 쓰인다.
      + 객체종료를 보장하기 위해서
    * 종료자 사용이 적합한 두 번째 경우는 네이티브 피어와 연결된 객체를 다룰때다.
      + 네이티브 피어는 일반 자바 객체가 네이티브 메서드를 통해 기능 수행을 위임하는 네이티브 객체를 말한다.
    * 하위 클래스에서 상위 클래스 종료자를 재정의(override)하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다.
    * 자원 반환에 대한 최종적 안전장치를 구현하거나, 그다지 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말라는 것이다.
      + 굳이 종료자를 사용해야 하는 드문 상황에 처했다면 super.finalize 호출을 잊지 말자.

### 모든 객체의 공통 메서드
  - Object는 객체 생성이 가능한 클래스(concrete class)이긴 하지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다.
  - 규칙 8 : equals를 재정의할 떄는 일반 규약을 따르라
    * equals를 재정의하지 않기 위한 조건
      + 각각의 객체가 고유하다.
      + 클래스에 "논리적 동일성(logical equality)" 검사 방법이 있건 없건 상관없다.
      + 상위 클래스에서 재정의 한 equals가 하위 클래스에서 사용하기에도 적당하다.
      + 클래스가 private 또는 package-private로 선언되었고, equals 메서드를 호출할 일이 없다.
    * 객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때, 그리고 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때 재정의 해야한다.
    * equals는 동치 관계를 구현한다.
      + 반사성 : 모든 객체는 자기 자신과 같아야 한다.
        - null이 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환한다.
      + 대치성 : 두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다는 것이다.
        - null이 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.
        - equals가 따라야 할 규약을 어기면, 그 객체를 만난 다른 객체들이 어떻게 행동할지 예측할 수 없게 된다.
      + 추이성 : 첫 번째 객체가 두 번째 객체와 같고, 두 번째 객체와 세 번째 객체와 같다면 세 번째 객체도 같아야 한다는 것이다.
        - null이 아닌 참조 x, y, z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.
        - 객체 생성가능 클래스를 계승하여 새로운 값 컴포넌트를 추가하면서 equals 규약을 어기지 않을 방법이 없다.
        - 리스코프 대체 원칙(LSP)은 어떤 자료형의 중요한 속성은 하위 자료형에도 그대로 유지되어서, 그 자료형을 위한 메서드는 하위 자료형에도 잘 동작해야 한다는 원칙이다.
      + 일관성 : 일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 되어야 한다는 것이다.
        - null 아닌 참조 x와 y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.
        - 변경 가능 여부에 상관없이, 신뢰성이 보장되는 않는 자원들을 비교하는 equals를 구현하는 것은 삼가라.
      + null에 대한 비 동치성 : 모든 객체는 null과 동치 관계에 있지 않는다.
        - null 이 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.
    * 훌륭한 equals 메서드를 구현하기 위해 따라야 할 지침
      1. == 연산자를 사용하여 equals의 인자가 자기 자신인지 검사하라.
      2. instanceof 연산자를 사용하여 인자의 자료형이 정확한지 검사하라.
      3. equals의 인자를 정확한 자료형으로 변환하라.
      4. "중요" 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.
      5. equals메서드 구현을 끝냈다면, 대칭성, 추이성, 일관성의 세 속성이 만족되는지 검토하라.
      + equals를 구현할 때는 hashCode도 재정의하라.
      + 너무 머리 쓰지 마라.
        - 일반적으로 보면 앨리어싱까지 고려한 동치성 검사는 바람직하지 않다.
      + equals 메서드의 인자 형을 Object에서 다른 것으로 바꾸지 마라.
  - 규칙 9 : equals를 재정의할 떄는 반드시 hashCode도 재정의하라
    * equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야한다.
      + 그렇지 않으면 Object.hashCode의 일반규약을 어기게 되므로, HashMap, HashTable같은 해시(hash)기반 컬렉션과 함께 사용하면 오동작하게 된다.
    * hashCode를 재정의하지 않으면 위반되는 핵심규약은 두 번째다. 같은 객체는 같은 해시코드 값을 가져야 한다는 규약이 위반되는 것이다.
    * 가장 끔찍한 형태의 해시 함수, 절대로 이렇게 구현하지 말 것
      + @override public int hashCode(){ return 42; }
    * 이상적인 해시 함수는 서로 다른 객체들을 모든 가능한 해시 값에 균등하게 배분해야 한다.
    * 주의할 것은, 성능을 개선하려고 객체의 중요 부분을 해시코드 계산 과정에서 생략하면 안 된다는 것이다.

  - 규칙 10 : toString은 항상 재정의하라
    * toString을 잘 만들어 놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.
    * toString 메서드를 재정의하면 해당 객체만 해택을 보는 것이 아니라 해당 객체에 대한 참조를 유지하는 객체들, 특히 컬렉션까지 혜택을 본다.
    * 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다.
    * toString이 반환하는 문자열의 형식을 문서에 명시하면, 표준적이고 분명하며 사람이 읽기 쉬운 객체 표현법 구실을 한다는 장점이 있다.
    * toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에, 어떤 의도인지는 문서에 분명하게 남겨야 한다.
    * 문자열 형식을 명시하건 그렇지 않건 간에, toString이 반환하는 문자열에 포함되는 정보들은 전부 프로그래밍을 통해서 가져올 수 있도록 하라.
  - 규칙 11 : clone을 재정의할 때는 신중하라.
    * Cloneable은 어떤 객체가 복제(clone)을 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인 인터페이스다.
    * 인터페이스에는 clone 메서드가 없으며, Object의 Clone 메서드는 protected로 선언되어 있다는 것이다.
      + 리플렉션을 사용하지 않고는 Cloneable을 구현한 객체라 해도 clone 메서드를 호출할 방법이 없다.
    * 비-final 클래스에 clone을 재정의할 때는 반드시 super.clone을 호출해 얻은 객체를 반환해야 한다.
    * 실질적으로 Cloneable 인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 한다.
    * 공변 반환형(covariant return type)
      + 재정의 메서드(overriding method)의 반환값 자료형은 재정의 되는 메서드의 반환값 자료형의 하위 클래스가 될 수 있다.  
      + 덕분에 재정의 메서드는 반환될 객체에 대한 더 많은 정보를 제공할 수 있고, 클라이언트는 형 변환을 하지 않아도 된다.
    * 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말라.
    * 사실상 clone 메서드는 또 다른 형태의 생성자다. 원래 객체를 손상시키는 일이 없도록 해야 하고, 복사본의 불변식(invariant)도 제대로 만족시켜야 한다.
    * 배열에 clone을 호출하면 반환되는 배열의 컴파일 시점(compile-time) 자료형은 복제 대상 배열의 자료형과 같다.
    * clone의 아키텍처는 변경 가능한 객체를 참조하는 final 필드의 일반적 용법과 호환되지 않는다.
    * 꼭 필요한 경우가 아니라면 객체를 복사할 대안을 제공하거나, 아예 복제 기능을 제공하지 않는 것이 낫다.
    * 객체 복제를 지원하는 좋은 방법은, 복사 생성자(copy constructor)나 복사 팩터리(copy factory)를 제공하는 것이다.

  - 규칙 12 : comparable 구현을 고려하라.
    * Comparable 인터페이스를 구현하는 클래스의 객체들은 자연적 순서(natural ordering)를 갖게 된다.
    * compareTo 메서드의 일반 규약은 equals와 비슷하다.
    * 객체참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 그대로 유지되어야 한다.
    * 첫 번째 객체가 두 번째 객체보다 크고 두 번쨰 객체가 세 번째 객체보다 클 경우 첫 번째 객체는 반드시 세 번째보다 커야 한다는 사실을 표현한다.
    * compareTo를 통한 동치성 검사 결과는 일반적으로 equals 메서드 실행 결과와 같아야 한다는 것은 강력한 권고사항이다.
### 클래스와 인터페이스
  - 클래스와 인터페이스는 자바 프로그래밍 언어의 핵심적인 부분으로서, 추상화의 기본 단위다.

  - 규칙 13 : 클래스와 멤버의 접근 권한은 최소화하라.
    * 세부구현사항은 API 뒤쪽으로 감추고 모듈들은 이 API를 통해서만 서로 통신하며, 각자 내부적으로 무슨 짓을 하는지는 신경 쓰지 않는다.
      + 정보은닉(information hiding) 또는 캡슐화(encapsulation)이라고 한다.
    * 정보 은닉 원칙이 좋은 성능을 자동적으로 보장하는 것은 아니지만, 효과적인 성능 튜닝을 가능하게 하는것은 사실이다.
    * 접근 제어 메커니즘은 클래스와 인터페이스, 그리고 그 멤버들의 접근 권한을 규정한다.
    * 각 클래스와 멤버는 가능한 한 접근 불가능하도록 만들어라.
      + 개발중인 소프트웨어의 정상적인 동작을 보증하는 한도 내에서 가장 낮은 접근 권한을 설정하라는 것이다.
      + 최상위 레벨 클래스나 인터페이스는 가능한 package-private로 선언해야 한다.
    * 접근 권한 증가순서
      + private : 이렇게 선언된 멤버는 선언된 초상위 레벨 클래스 내부에서만 접근 가능하다.
      + package-private :  이렇게 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 권한 으로 알려져있는데, 멤버를 선언할 때 아무런 접근 권한 수정자도 붙이지 않으면, 이권한 이 주어진다.
      + protected : 이렇게 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있다. 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용가능하다.
      + public : 이렇게 선언된 멤버는 어디서도 사용이 가능하다.
    * 객체 필드(instance field)는 절대로 public으로 선언하면 안된다.
      + 필드가 변경될 때 특정한 동작이 실행 되도록 할수도 없으므로, 변경가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않다.
    * 길이가 0이 아닌 배열은 언제나 변경 가능하므로 public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자를 정의하면 안된다.

  - 규칙 14 : public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라.
    * 선언된 패키지 ㅂㄲ에서도 사용 가능한 클래스에는 접근자 메서드를 제공하라.
    * package-private 클래스나 private 중첩 클래스는 데이터필드를 공개하더라도 잘못이라 말할 수 없다.

  - 규칙 15 : 변겨 가능성을 최소화 하라.
    * 변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스다.
    * 변경 불가능 클래스는 변경 가능 클래스보다 설계하기 쉽고 구현하기 쉬우며, 사용하기도 쉽다. 오류가능성도 적고, 더 안전하다.
    * 변경 불가능 클래스의 다섯 규칙
      1. 객체 상태를 변경하늠 메서드(수정자 메서드 등)를 제공하지 않는다.
      2. 계승할 수 없도록 한다.
        + 보통 final로 선언하면 된다.
      3. 모든 필드를 final로 선언한다.
      4. 모든 필드를 private로 선언한다.
      5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.
        + 생성자나 접근자, readObject메서드 안에서는 방어적 복사본을 만들어야 한다.
    * 변경 불가능 객체는 단순하다.
      + 생성될 때 부여된 한 가지 상태만 갖는다.
    * 변경 불가능 객체는 스레드에 안전 할 수밖에 없다.
      + 어떤 동기화도 필요 없으며, 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없다.
    * 변경 불가능한 객체는 자유롭게 공유할 수 있다.
    * 변경 불가능한 객체는 그 내부도 공유할 수 있다.
    * 변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다.
    * 변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.
      + 객체 생성 비용이 높을 가능성이 있다.
    * 모든 get메서드마다 그에 대응하는 set메서드를 두는 것은 피해야 한다.
      + 변경 가능한 클래스로 만들 타당한 이유가 없다면, 반드시 변경 불가능 클래스로 만들어야 한다.
    * 변경 불가능 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라.
    * 특별한 이유가 없다면 모든 필드는 final로 선언하라.
    * "재 초기화(reinitalize)"메서드도 제공하지 마라. 코드 복잡성만 늘어나고, 성능 향상에 도움 되는 경우는 거의 없다.

  - 규칙 16 : 계승하는 대신 구성하라.
    * 계승은 상위 클래스와 하위클래스 구현을 같은 프로그래머가 통제하는 단일 패키지 안에서 사용하면 안전하다.
    * 한 클래스가 다른 클래스를 'extends'하는 것을 계승이라고 한다.
      + 어떤 클래스가 다른 인터페이스를 'implements'하거나 어떤 인터페이스가 다른 인터페이스를 'extends'하는 경우에는 적용되지 않는다.
    * 메서드 호출과 달리, 계승은 캡슐 원칙을 위반한다.
      + 하위클래스가 정상 동작하기 위해서는 상위 클래스의 구현에 의존할 수밖에 없다.
    * 기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 private 필드를 하나 두어 문제를 해결하는 설계 기법을 구성(composition)이라고 부른다.
      + 기존클래스가 새클래스의 일부가 된다.
    * 새로운 클래스에 포함된 각각의 메서드는 기존 클래스에 있는 메서드 가운데 필요한 것을 호출해서 그 결과를 반환하는 기법을 전달이라고 하고, 전달 기법을 사용해 구현된 메서드를 전달 메서드라고 부른다.
    * 계승은 하위 클래스가 상위 클래스의 하위 자료형(subtype)이 확실한 경우에만 바람직하다.
    * 요약
      + 계승은 강력한 도구이지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다는 것이다. 상위 클래스와 하위 클래스 사이에 IS-A 관계가 있을 때만 사용하는 것이 좋다. 설사 IS-A 관계가 성립해도, 하위 클래스가 상위 클래스와 다른 패키지에 있거나 계승을 고려해 만들어진 상위클래스가 아니라며, 하위 클래스는 깨지기 쉽다. 이런 문제를 피하려면 구성과 전달 기법을 사용하는 것이좋다. 데코레이션 패턴 구현에 적당한 인터페이스가 있다면 더욱 그렇다. 데코레이션 클래스는 하위 클래스보다 견고할 뿐 아니라, 더 강력하다.

  - 규칙 17 : 계승을 위한 설계 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라.
    * 메서드를 재정의하면 무슨 일이 생기는지 정확하게 문서로 남겨야 한다. 다시말해, 재정의 가능 메서드를 내부적으로 어떻게 사용하는지(self-use) 반드시 문서에 남겨라.
    * 클래스 내부 동작에 개입할 수 있는 훅(hooks)을 신중하게 고른 protected 메서드 형태로 제공해야 한다.
    * 계승을 위해 설계한 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는 것이다.
    * 생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출 해서는 안 된다는 것이다.
      + clone이나 readObject메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 주의해야 한다는 것이다.
    * 계승을 위해 클래스를 설계하면 클래스에 상당한 제약이 가해진다.
    * 변경불가능 클래스라면 계승은 배재해야한다.
    * 계승에 맞도록 설계하고 문서화하지 않은 클래스에 대한 하위 클래스는 만들지 않는다.
    * 클래스 생성을 금지하는 방법
      + 클래스를 final로 선언하는 것
      + 대안 : 모든 생성자를 private이나 package-private로 선언하고 생성자대신 public 정적 팩터리 메서드를 추가하는 것

  - 규칙 18 : 추상 클래스 대신 인터페이스를 사용하라.
    * 이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.
    * 자바는 다중상속을 허용하지 않기 때문에, 추상 클래스를 사용하게 되면 자료형으로 사용하는 데 많은 제약이 발생하게 된다.
    * 인터페이스는 믹스인을 정의하는 데 이상적이다.
      + 믹스인은 클래스가 '주 자료형' 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.
    * 인터페이스는 비 계층적인 자료형 프레임워크를 만들수 있도록 한다.
    * 인터페이스를 사용하면 포장 클래스 숙어(wrapper class idiom)을 통해 안전하면서도 강력한 기능 개선이 가능하다.
      + 추상클래스를 사용해 자료형을 정의하면 프로그래머는 계승 이외의 수단을 사용할 수 없다.
      + 그렇게 해서 만든 클래스는 포장 클래스 보다 강력하지도 않고, 깨지기도 쉽다.
    * 추상 골격 구현 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합 할 수 있다.
    * 모의 가상 상속 : 골격 구현 클래스를 계씅하는 private 내부 클래스를 정의하고 인터페이스 메서드에 대한 호출은 해당 중첩 클래스 객체로 전달 하는 것이다.
    * 다양한 구현을 허용하는 자료형을 추상 클래스로 정의하면 인터페이스보다 나은 점이 한가지 있는데, 인터페이스보다는 추상 클래스가 발전 시키기 쉽다는 것이다.
    * 인터페이스가 공개되고 널리 구현된 다음에는, 인터페이스 수정이 거의 불가능하기 떄문이다.

  - 규칙 19 : 인터페이스는 자료형을 정의할 때만 사용하라.
    * 인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형 역할을 하게 된다.
    * 상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.
    * 인터페이스는 자료형을 정의할 때만 사용해야 한다.
    * 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.

  - 규칙 20 : 태그 달린 클래스 대신 클래스 계층을 활용하라.
    * 태그 기반 클래스는 너저분한데다 오류 발생가능성이 높고, 효율적이지도 않다.
    * 태그 기반 클래스는 클래스 계층을 얼기설기 흉내 낸 것일 뿐이다.
    * 태그 기반 클래스를 클래스 계층으로 변환하려면, 먼저 태그 값에 따라 달리동작하는 메서드를 추상 메서드로 선언하는 추상 클래스를 정의해야 한다.
    * 클래스 계층의 또 다른 장점은 자료형 간의 자연스러운 계층 관계를 반영할 수 있어서 유연성이 높아지고 컴파일 시에 형 검사를 하기 용이하다는 것이다.
    * 태그 기반 클래스 사용은 피해야 한다. 클래스 안에 태그 필드를 명시적으로 두고 싶다는 생각이 든다면, 클래스 계층을 통해 태그를 제거할 방법이 없는지 생각해보기 바란다. 태그 필드가 있는 클래스를 만나게 된다면, 리펙터링을 통해 클래스 계층으로 변환할 방법은 없는지 고민해 보기 바란다.

  - 규칙 21 : 전략을 표현하고 싶을 때는 함수 객체를 사용하라.
    * 함수 객체의 주된 용도는 전략 패턴을 구현하는 것이다.
    * 자바로 이 패턴을 구현하기 위해서는 전략을 표현하는 인터페이스를 선언하고, 실행 가능 전략 클래스가 전부 해당 인터페이스를 구현하도록 해야 한다.
    * 실행 가능 전략이 한 번만 사용되는 경우에는 보통 그 전략을 익명 클래스 객체로 구현한다.
    * 반복적으로 사용된다면 private static멤버 클래스로 전햑을 표현한 다음, 전략 인터페이스가 자료형인 public static final 필드를 통해 외부에 공개하는 것이 바람직 하다.

  - 규칙 22 : 멤버 클래스는 가능하면 static으로 선언하라.
    * 중첩 클래스는 다른 클래스 안에 정의된 클래스다.
    * 중첩 클래스는 해당 클래스가 속한 클래스 안에서만 사용된다.
    * 중첩 클래스에는 네 가지 종류가 있다.
      + 정적 멤버 클래스
      + 비-정적 멤버 클래스
      + 익명 클래스
      + 지역 클래스
    * 바깥 클래스 객체에 접근할 필요가 없는 멤버 클래스를 정의할 떄는 항상 선언문 앞에 static을 붙여서 비-정적 멤버 클래스 대신 정적 멤버 클래스를 만들자.
    * 익명 클래스를 사용하는 데는 많은 계약이 있다.
      + 선언하는 순간에만 객체를 만들 수 있다.
    * 여러 인터페이스를 구현하는 익명 클래스는 선언할 수 없으며, 인터페이스를 구현하는 동시에 특정한 클래스를 계승하는 익명 클래스도 만들 수 없다.
    * 익명 클래스는 함수 객체를 정의할 때 널리 쓰인다.
    * 익명 클래스는 Runnable, Thread, TimerTask 객체 같은 프로세스 객체를 만드는 데도 널리 쓰인다.
      + 정적 팩터리 메서드 안에서도 많이 쓰인다.
    * 중첩 클래스를 메서드 밖에서 사용할 수 있어야 하거나, 메서드 안에 놓기에 너무 길 경우에는 멤버 클래스로 정의하라.
    * 멤버 클래스의 객체 각각이 바깥 객체에 대한 참조를 가져야 하는 경우에는 비-정적 멤버 클래스로 만들라.
      + 그렇지 않은 경우에는 정적 멤버 클래스로 만들면 된다.
      + 중첩 클래스가 특정한 메서드에 속해야 하고, 오직 한곳에서만 객체를 생성하며, 해당 중첩클래스의 특성을 규정하는 자료형이 이미 있다면 익명 클래스로 만들면 된다.

### 제네릭
  - 자바 1.5부터 제네릭이라는 개념을 지원하기 시작했다.
  - 제네릭을 사용하면 컬렉션에 넣는 객체의 자료형이 무엇인지 컴파일러에게 알릴 수 있다.
  - 규칙 23 : 새 코드에는 무인자 제네릭 자료형을 사용하지 마라.
    * 선언부에 형인자가 포함된 클래스나 인터페이스는 제니릭 클래스나 인터페이스라고 부른다.
    * 제네릭 클래스와 인터페이스는 제네릭 자료형이라 부른다.
    * 주석 대신 제니릭을 쓰면, 컴파일러에게 컬렉션에 담길 객체의 자료형이 무엇인지 선언할 수 있다.
    * 형인자 자료형을 쓰면 컬렉션에서 원소를 꺼낼 때 형변환을 하지 않아도 된다.
    * 무인자 자료형을 쓰면 형 안전성이 사라지고, 제네릭의 장점 중 하나인 표현력 측면에서 손해를 본다.
    * List는 형 검사 절차를 완전히 생략한 것이고, List<Object>는 아무 객체나 넣을 수 있다는 것을 컴파일러에게 알리는 것이다.
    * List와 같은 무인자 자료형을 사용하면 형 안전성을 잃게 되지만, List<Object>와 같은 형인자 자료형을 쓰면 그렇지 않다.
    * 비한정적 와일드카드 자료형
      + 제네릭 자료형을 쓰고 싶으나 실제 형 인자가 무엇인지 모르거나 신경 쓰고 싶지 않을 때는 형 인자로 '?'를 쓰면 된다.
    * 한정적 와일드 카드 : 'List<E extends A>' A의 하위 자료형만 올수있다.
    * 예외규칙
      + 클래스 리터럴에는 반드시 무인자 자료형을 사용해야 한다.
      + instanceof 연산자는 비 한정적 와일드 카드 자료형 이외의 형인자 자료형에는 적용할 수 없다.
    * 무인자 자료형을 쓰면 프로그램 실행 도중에 예외가 발생할 수 있으므로 새로 만드는 코드에는 무인자 자료형을 쓰지 말아야 한다.
    * 무인자 자료형은 제네릭 도입 전에 작성된 코드와 호환성을 유지하기 위해 제공되는 것에 불과하다.

  - 규칙 24 : 무점검 경고(unchecked warning)를 제거하라.
    * 모든 무점검 경고는, 가능하다면 없애야 한다.
    * 제거할 수 없는 경고 메시지는 형 안전성이 확실할 때만 @SupressWarnings("unchecked") 어노테이션을 사용해 억제하기 바란다.
    * SupressWarnings 어노테이션은 가능한 한 작은 범위에 적용하라.
    * @SupressWarnings("unchecked") 어노테이션을 사용할 때마다, 왜 형 안전성을 위반하지 않는지 밝히는 주석을 반드시 붙여라.
    * 경고메시지는 최선을 다해 제거하라.

  - 규칙 25: 배열 대신 리스트를 써라.
    * 배열은 제네릭 자료형과 두 가지 중요한 차이점이 있다.
      + 배열은 공변 자료형, 제네릭은 불변 자료형
      + 배열은 실체화 되는 자료형 : 배열의 각 원소의 자료형은 실행시간에 결정된다.
      + 배열과 제네릭은 섞어 쓰기 어렵다. : 형 안전성이 보장되지 않기 떄문이다.
    * 요약
      + 배열은 공변자료형이자 실체화 가능 자료형이다. 제네릭은 불변자료형이며, 실행시간에 형인자의 정보가 삭제된다.
      + 배열은 컴파일시간에 형 안전성을 보장하지 못하며, 제네릭은 그 반대다.

  - 규칙 26 : 가능하면 제네릭 자료형으로 만들 것
    * 제네릭 자료형은 클라이언트가 형변환을 해야만 사용할 수 있는 자료형보다 안전할 뿐 아니라 사용하기도 쉽다.
    * 새로운 자료형을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 그러려면 제네릭 자료형으로 만들어야 할 때가 많을 것이다.
    * 시간이 있을 때마다 기존 자료형을 제네릭자료형으로 변환하라.
    * 기존 클라이언트 코드를 꺠지 않고도 새로운 사용자에게 더 좋은 API를 제공할 수 있게 될 것이다.

  - 규칙 27 : 가능하면 제네릭 메서드로 만들 걸
    * 형인자를 선언하는 형인자 목록(Type parameter list)은 메서드의 수정자(modifier)와 반환값 자료형 사이에 둔다.
    * 제네릭 메서드의 주목할 만한 특징 하나는, 제네릭 생성자를 호출할 때는 명시적으로 주어야 했던 형인자를 전달할 필요가 없다는 것이다.
    * 전달된 인자 등을 통해 컴파일러가 자료형을 알아내는데 이 과정을 자료형 유추라고 한다.
    * 제네릭 메서드를 호출할 때 자료형이 유추되는 것을 이용하면, 형인자 자료형 객체를 좀 더 쉽게 생성할 수 있다.
    * 자료형 한정 <T extends Comparable<T>>는 "자기 자신과 비교 가능한 모든 자료형 T"라는 뜻으로 읽을 수 있다.
      + 상호 비교 가능성이라는 개념을 어느 정도 정확하게 표현하는 문장이다.
    * 제네릭 자료형이나 마찬가지로 제네릭 메서드는 클라이언트가 직접 입력값과 반환값의 자료형을 형변환해야 하는 메서드보다 사용하기 쉽고 형 안정성도 높다.

  - 규칙 28 : 한정적 와일드 카드를 써서 API 유연성을 높여라
    * 자바는 한정적 와일드 카드 자료형이라는 특별한 형인자 자료형을 제공한다.
      + Iterable<? extends E> : E의 하위 자료형의 Iterable이라고 명시하는 코드
    * 유연성을 최대화하려면, 객체 생산자 구실을 하는 메서드 인자의 자료형은 와일드 카드 자료형으로 하라는 것이다.
    * 인자가 T 생산자라면 <? extends T>라고 하고, T 소비자라면 <? super T>로 사용한다.
    * 반환값에는 와일드카드 자료형을 쓰면 안 된다.
      + 좀 더 유연한 코드를 만들 수 있도록 도와주기는 커녕, 클라이언트 코드 안에도 와일드 카드 자료형을 명시해야 하기 때문이다.
    * 클래스 사용자가 와일드카드 자료형에 대해 고민하게 된다면, 그것은 아마도 클래스API가 잘못 설계된 탓일 것이다.
    * 형인자가 메서드 선언에 단 한군데 나타난다면 해당 인자를 와일드카드로 바꾸라는 것이다.
      + 비한정적 형인자이면 비한정적 와일드카드로 바꾸고, 한정적 형인자이면 한정적 와일드카드로 바꿔라
    * 생산자는 extends이고 소비자는 super라는 기본적 규칙을 암기하라.

  - 규칙 29 : 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라
    * 자료형 토큰(type token)
    * 상위 자료형 토큰(super type token)
      + 참조 :https://github.com/jojonari/TIL/blob/master/%ED%86%A0%EB%B9%84%EC%9D%98_%EB%B4%84/02_%EC%88%98%ED%8D%BC%ED%83%80%EC%9E%85%ED%86%A0%ED%81%B0.md
    * 컬렉션 API를 통해 확인할 수 있는 제네릭의 일반 용법에 따르면, 컨테이너별로 형인자 개수는 고정되어 있다.
    * 컨테이너 대신 키를 제니릭으로 만들면 그런 제약이 없는 형 안전 다형성 컨테이너를 만들 수 있다.

### 열거형과 어노테이션

  - 규칙 30 : int 상수 대신 enum을 사용하라
    * 열거 자료형(enumerated type)은 고정 개수와 상수들로 값이 구성되는 자료형이다.
    * 열거형을 사용하기 이전에는 통상 int형의 상수들을 정의해서 열거 자료형을 처럼 썼는데 이를 int enum 패턴이라고 한다.
    * int 대신 String 상수를 사용하는 것은 String enum 패턴이라고 한다.
    * 클라이언트가 enum 자료형으로 새로운 객체를 생성하거나 계승을 통해 확장할 수 없기 때문에, 이미 선언된 enum 상수 이외의 객체는 사용할 수 없다.
    * enum 상수에 데이터를 넣으려면 객체필드를 선언하고 생성자를 통해 받은 데이터를 그 필드에 저장하면 된다.
    * 상수별 클래스 몸체 안에서 실제 메서드로 재정의하는 것을 '상수별 메서드 구현'이라고 한다.
    * 외부 자료형 상수별로 달리 동작하는 코드를 만들어야 할 떄는 enum 상수에 switch문을 적용하면 좋다.
    * enum을 사용한 코드는 가독성이 높고, 안전하며, 더 강력하다.
    * 상당수의 enum은 생성자나 멤버가 필요 없으나, 데이터 또는 그 데이터에 관계된 메서드를 추가해서 기능을 확장시키기도 한다.

  - 규칙 31 : ordinal 대신 객체 필드를 사용하라.
    * enum에는 ordinal이라는 메서드가 있는데, enum 자료형 안에서 enum 상수의 위치를 나타내는 정수 값을 반환한다.
    * enum 상수에 연계되는 값을 ordinal을 사용해 표현하지 말아야 한다.
      + 그런 값이 필요하다면 그 대신 객체 필드에 저장해야한다.

  - 규칙 32 : 비트 필드 대신 enumSet을 사용하라.
    * EnumSet이라는 클래스를 사용하면 특정한 enum 자료형의 값으로 구성된 집합을 효율적으로 표현 할 수 있다.
    * 열거 자료형을 집합에 사용해야 한다고 해서 비트 필드로 표현하면 곤란하다.

  - 규칙 33 : ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라.
    * enum 상수를 어떤 값에 대응 시킬 목적으로 배열을 사용한다면 Map을 쓰는게 좋다.
    * 표현해야 하는 관계가 다차원적이라면, EnumMap<..., EnumMap<...>>과 같이 표현하면 된다.

  - 규칙 34 : 확장 가능한 enum을 만들어야 한다면 인터페이스를 활용하라.
    * enum 자료형이 임의의 인터페이스를 구현할 수 있다
    * 한정적 와일드카드 자료형 Collection<? extends Operation>을 opSet 인자의 자료형으로 사용한다.
    * 계승 가능 enum 자료형은 만들수 없지만, 인터페이스를 만들고 그 인터페이스를 구현하는 기본 enum 자료형을 만들면 계승 가능 enum자료형을 흉내 낼 수 있다.

  - 규칙 35 : 작명 패턴 대신 어노테이션을 사용하라.
    * 어노테이션이 있으므로 더 이상은 작명 패턴에 기대면 안된다.
    * 대부분의 프로그래머는, 도구 개발에 관심있는 개발자가 아니라면, 어노테이션 자료형을 정으할 필요가 없다.
    * 모든 프로그래머는 자바 플랫폼이 제공하는 어노테이션 자료형들을 사용하도록 해야한다.

  - 규칙 36 : override 어노테이션은 일관되게 사용하라.
    * 상위 클래스에 선언된 메서드를 재정의할 때는 반드시 선언부에 override 어노테이션을 붙여야 한다.
    * 추상 클래스나 인터페이스의 경우에는 그 상위 클래스나 상위 인터페이스 메서드를 재정의하는 모든 메서드에, abstract 메서드건 아니건 상관없이 어노테이션을 붙일 필요가 있다.

  - 규칙 37 : 자료형을 정의할 때 표식 인터페이스를 사용하라.
    * 표식 인터페이스 : 아무 메서드도 선언하지 않은 인터페이스
    * 클래스를 만들 때 표식 인터페이스를 구현하는 것은, 해당 클래스가 어떤 속성을 만족한다는 사실을 표시하는 것과 같다.
    * 표식 인터페이스는 결국 표식 붙은 클래스가 만드는 객체들이 구현하는 자료형이라는 점이다. 표식 어노테이션은 자료형이 아니다.

### 메서드
  - 규칙 38 : 인자의 유효성을 검사하라.
    * 대부분의 메서드와 생성자는 인자로 사용할 수 있는 값을 제한한다.
    * public 메서드라면, 인자 유효성이 위반되었을 경우에 발생하는 예외를 Javadoc의 @throws 태그를 사용해서 문서화하라
    * 메서드나 생성자를 구현할 때는 받을 수 있는 인자에 제한이 있는지 따져봐야 한다. 그리고 제한이 있다면 그 사실을 문서에 남기고, 메서드 앞부분에서 검사하도록 해야 한다.

  - 규칙 39 : 필요하다면 방어적 복사본을 만들라.
    * 여러분이 만드는 클래스의 클라이언트가 불변식을 망가뜨리기 위해 최선을 다할 것이라는 가정하에, 방어적으로 프로그래밍 해야한다.
    * 특정 객체의 내부를 보호하려 생성자로 전달되는 변경 가능 객체를 반드시 방어적으로 복사해서 그 복사본을 특정 객체의 컴포넌트로 이용해야 한다.
      - 유효성 검사는 복사본에 대해서 시행한다.
    * 인자로 전달된 객체의 자료형이 제3자가 계승할 수 있는 자료형일 경우, 방어적 복사본을 만들 떄 clone을 사용하지 않도록 해야 한다.
    * 변경 가능 내부 필드에 대한 방어적 복사본을 반환하도록 접근자를 수정해야 한다.
    * 방어적 복사는 변경불가능 클래스에만 쓰이는 기법은 아니다. 클라이언트가 제공한 객체를 내부 자료구조에 반영하는 생성자나 메서드에는 사용 가능하다.
    * 클라이언트로 부터 구했거나 클라이언트에게 반환되는 변경 가능 컴포넌트가 있는 경우, 해당 클래스는 그 컴포넌트를 반드시 방어적으로 복사해야 한다.

  - 규칙 40 : 메서드 시그너처는 신중하게 설계하라.
    * 메서드 이름은 신중하게 고르라.
    * 편의 메서드를 제공하는 데 너무 열 올리지 마라.
      + 모든 메서드는 "맡은 일이 명확하고 거기에 충실"해야 한다.
    * 인자 리스트를 길게 만들지 마라.
      + 자료형이 같은 인자들이 길게 연결된 인자 리스트는 특히 더 위험하다.
    * 인자의 자료형으로는 클래스보다 인터페이스가 좋다.
    * 인자 자료형으로 Boolean을 쓰는 것보다는, 원소가 2개인 enum 자료형을 쓰는 것이 낫다.

  - 규칙 41 : 오버로딩할 때는 주의하라.
    * 오버로딩된 메서드 가운데 어떤 것이 호출될지는 컴파일 시점에 결정되기 때문이다.
    * 오버로딩된 메서드는 정적으로 선택되지만, 재정의된 메서드는 동적으로 선택되기 때문이다.
    * 오버로딩을 사용할 떄는 혼란스럽지 않게 사용할 수 있도록 주의해야한다.
      + 혼란을 피하는 안전하고 보수적인 전략은, 같은 수의 인자를 갖는 두 개의 오버로딩 메서드를 API에 포함시키지 않는 것이다.
    * 메서드를 오버로딩할 수 있다고 해서 반드시 그래야하는 것은 아니다.
      + 인자 개수가 같은 오버로딩 메서드를 추가하는 것은 일반적으로 피해야 한다.

  - 규칙 42 : varargs는 신중히 사용하라
    * 자바 1.5부터는 공식적으로는 가변 인자 메서드라고 부르는 varargs 메서드가 추가되었다.
    * varargs는 정말로 임의 개수의 인자를 처리할 수 있는 메서드를 만들어야 할 떄만 사용하라.
    * 성능이 중요한 환경이라면 varargs 사용에 더욱 신중해야 한다.
