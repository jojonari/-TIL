클린 코드 - 01 깨끗한 코드
=============================

> 도서 : Clean Code(클린 코드)애자일 소프트웨어 장인 정신
> 저자 : 로버트 C. 마틴

1. 깨끗 한 코드
  - 비야네.스트룹
    * 의존성을 최대한 줄여야 한다.
    * 깨끗한 코드는 한 가지를 제대로 한다.
  - 그래디 부치
    * 의미있는 이름이 붙는다.
  - 데이브 토마스
    * 잘 쓴 문장처럼 읽힌다.
  - 마이클 페더스
    * 주의깊게 짰다는 느낌이다.
  - 론 제프리
    * 중복을 피해라.
    * 한 기능만 수행하라.
    * 제대로 표현하라.
    * 작게 추상화 하라
  - 개발자는 코드를 작성하는 시간보다 읽는 시간이 월등히 길다.
  - 보이스카웃 규칙
    * "캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라"

2. 의미 있는 이름
  -  의도를 분명히 밝혀라.
    * 존재이유, 수행기능, 사용방법이 드러나야 한다.
  - 그릇된 정보를 피해라.
    * 유사한 개념은 유사한 표기법을 사용한다.
    * 일관성이 떨어지는 표기법은 그릇된 정보다.
  - 의미있게 구분하라.
    * 이름이 달라야 한다면, 의미도 달라야 한다.
    * 읽는 사람이 차이를 알도록 이름을 지어라.
  - 발음하기 쉬운 이름을 사용하라.
    * 공유 가능한 이름을 사랑한다.
  - 검색하기 쉬운 이름을 사용하라.
    * 이름 길이는 범위 크기에 비례해야 한다.
  - 인코딩을 피해라.
    * 문제해결에 집중하는 개발자에게 인코딩은 불필요한 정신적 부담이다.
  - 자신의 기억력을 자랑하지 마라
    * 문자 하나만 쓰는 변수는 작은 루프의 반복 횟수를 세는 변수에만 사용해라. (i, j 등)
    * "명료함이 최고다"
  - 클래스 이름
    * 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
  - 메서드 이름
    * 메서드명은 동사나 동사구가 적합하다.
    * 생성자를 중복정의 할 때는 정적 팩토리 메서드를 사용한다.
  - 한 개념에 한 단어를 사용하라.
    * 일관성 있는 어휘코드를 사용하라.
  - 말장난을 하지마라
    * 다른 개념에 같은 단어를 사용하지 마라
    * 의미를 해독 할 책임이 독자에 있는 논문 모델이 아니라, 의도를 밝힐 책임이 저자에 있는 잡지 모델이 바람직하다.
  - 해법영역에서 가져온 이름을 사용하라.
    * 코드를 읽는 사람도 개발자다.
    * 전산용어, 알고리즘 이름, 패턴명, 수학 용어 등을 사용해라.
  - 문제영역에서 가져온 이름을 사용하라.
    * 적절한 프로그래머용어가 없으면, 문제 영역에서 이름을 가져와라.
    * 문제영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.
  - 의미있는 맥락을 추가하라.(접두어 등)
    * 함수 이름은 맥락일부만 제공하며, 알고리즘이 나머지 맥락을 제공한다.
    * 맥락을 개선하면 함수 쪼개기가 쉬워지므로 알고리즘도 더 명확해진다.
  - 불필요한 맥락을 없애라.
    * 일반적으로 짧은 이름이 긴 이름보다 좋다.
    * 이름에 불필요한 맥락을 추가하지 않도록 주의한다.

3. 함수
  - 어떤 프로그램이든 가장 기본적인 단위가 함수다.
  - 작게 만들어라.
    * 함수를 만드는 첫째 규칙은 '작게''다. 함수를 만드는 둘째 규칙은 '더 작게'다.
    * if/else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
  - 한 가지만 해라.
    * 함수는 한가지를 해야한다. 그리고 그 한가지를 잘해야 한다. 그 한가지만을 해야만 한다.
    * 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한다.
    * 단순히 다른 표현이 아니라, 의미있는 이름으로 다른 함수를 추출 할 수 있다면 그 함수는 여러작업을 하는 셈이다.
  - 함수당 추상화 수준은 하나로.
    * 함수가 확실히 '한 가지' 작업만 하려면 함수내 모든 문장의 추상화 수준이 동일 해야 한다.
    * 내려가기 규칙 : 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아 진다.
  - switch문
    * switch문은 작게 만들기 어렵다.
    * 다형성을 이용하여 switch문을 저차원 클래스에 숨기고 절대 반복하지 않는 방법이 있다.
  - 서술적인 이름을 사용하라.
    * 이름이 길어도 괜찮다.
    * 길고 서술적인 이름이 길고 서술적인 주석보다 낫다.
    * 이름을 붙일때는 일관성이 있어야 한다. 모듈내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
  - 함수인수
    * 함수에서 이상적인 인수의 개수는 0개(무항)이다.
    * 4개 이상의 다항은 사용하면 안된다.
    * 최선은 입력인수가 없는 경우이며, 차선은 입력 인수가 하나인 겨우이다.
    * 많이 쓰는 다항 형식
      + 인수에 질문을 던지는 경우
      + 인수를 뭔가로 변환해 결과를 반환하는 경우
      + 이외의 경우는 단항 함수를 가급적 피한다.
    * 플래그인수
      + 함수가 한꺼번에 여러가지 일을 한다.
    * 인수객체
      + 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
  - 부수효과를 일으키지마라
  - 명령과 조회를 분리하라.
   * 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
  - 오류코드보다 예외를 사용하라.
    * 오류처리도 한가지 작업이다.
  - 반복하지 마라
    * 중복은 소프트웨어에서 모든 악의 근원이다.
    * 객체지향 프로그래밍은 코드를 부모클래스로 몰아 중복을 없앤다.
  - 구조적 프로그래밍
    * 데이크스트 왈 "모든 함수와 함수내 모든 블록에 입구와 출구가 하마나만 존재해야 한다."
  - 함수는 그언어에서 동사며 클래스는 명사이다.

4. 주석
  - "나쁜 코드에 주석을 달지 마라, 새로짜라" - 플라우거
  - 잘 달린 주석은 그어떤 정보보다 유용하다.
  - 주석은 오래될수록 코드에서 멀어진다.
  - 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하다.
    * 코드의 복사, 수정 등을 진행할 때 코드는 관리가 되지만 주석은 관리된다는 보장이 없다.
  - 주석은 나쁜 코드를 보완하지 못한다.
    * 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
  - 코드로 의도를 표현하라!
    * 코드로 대다수 의도를 표현할 수 있다.
  - 좋은 주석
    * 법적인 주석
      + 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다.
    * 정보를 제공하는 주석
      + 정규표현식의 설명 등
    * 의도를 설명하는 주석
      + 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.
    * 의미를 명료하게 밝히는 주석
      + 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.
      + 주석이 올바른지 검증하기 쉽지 않으므로 각별히 주의한다.
    * 결과를 경고하는 주석
      + "//여유시간이 충분하지 않다면 실행하지 마십시오"와 같은 주석은 좋다.
      + 테스트코드의 경우 "@Ignore"를 사용해서 주석을 단다.
    * TODO 주석
      + 때로는 '앞으로 할 일'을 //TODO 주석으로 남겨두면 편하다.
      + 주기적으로 TODO주석을 점검해 없애도 괜찮은 주석은 없애라고 권한다.
    * 중요성을 강조하는 주석
    * 공개 API에서 JavaDocs
      + 공개 API를 구현한다면 반드시 훌륭한 JavaDocs를 작성한다.
  - 나쁜 주석
    * 대다수 주석이 이 범주에 속한다.
    * 주절거리는 주석
      + 주석을 달기로 결정 했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.
    * 같은 이야기를 반복하는 주석
      + 자칫하면 코드보다 주석을 읽는 시간이 더 오래걸린다.
    * 오해할 여지가 있는 주석
    * 의무적으로 다는 주석
      + 모든 함수에 주석을 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석다.
      + 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며, 잘못된 정보를 제공할 여지만 만든다.
      + 소스코드관리시스템이 있으므로 따로 이력을 남길 필요가 없다.
    * 있으나 마나 한 주석
      + 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석은 기록하지 마라
      + 잇으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리하라.
    * 무서운 잡음
    * 함수나 변수로 표현 할 수 있다면 주석을 달지마라.
    * 위치를 표시하는 주석
      + 너무 자주 사용하지 않는다면 배너는 눈에 띄며 주의를 환기한다. 그러므로 반드시 필요할 때만, 아주 드말게 사용하는것이 좋다.
    * 닫는 괄호에 다는 주석
      + 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.
    * 공로를 돌리거나 저자를 표시하는 주석
      + 이력에 관한 정보는 소스코드 관리 시스템에 저장하는 편이 좋다.
    * 주석으로 처리한 코드
      + 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어서 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다.
    * 전역정보
      + 주석을 달아야 한다면 근처에 잇는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라.
    * 너무 많은 정보
      + 주석에다 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라.
    * 모호한 관계
      + 주석과 주석이 설명하는 코드는 둘 사이에 관계가 명백해야 한다.
      + 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다.
    * 함수 헤더
      + 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.
    * 비공개 코드에서의 JavaDocs
      + 시스템 내부에 속한 클래스와 함수에 JavaDocs를 생성할 필요는 없다.

5. 형식 맞추기
  - 형식을 맞추는 목적
    * 코드 형식은 의사소통의 일환이다. 의사소통은 전문개발자의 일차적인 의무이다.
    * 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.
  - 적절한 행 길이를 유지하라.
    * 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.
    * 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.
  - 신문기사처럼 작성하라
    * 소스파일도 신문기사와 비슷하게 작성한다.
      + 이름은 간단하면서도 설명이 가능하게 짓는다.
      + 소스파일 첫 부분은 고차원 개념과 알고리즘을 설명한다.
      + 아래로 내려갈수록 의도를 세세하게 묘사한다.
      + 마지막에는 가장 저차원 함수와 세부내역이 나온다.
  - 개념은 빈 행으로 분리하라
    * 빈 행은 새로운 개념을 시작한다는 시각적 단서다.
  - 세로 밀집도
    * 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다.
    * 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.
  - 수직거리
    * 서로 밀접한 개념은 세로로 가까이 둬야 한다. 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.
    * 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다.
    * 변수선언
      + 변수는 사용하는 위치에 최대한 가까이 선언한다.
      + 짧은 함수의 경우 지역변수는 각 함수 맨 처음에 위치한다.
    * 인스턴스 변수
      + 인스턴스 변수는 클래스 맨 처음에 선언한다. 변수간에 세로로 거리를 두지 않는다.
      + 잘 설계한 클래스는 많은 클래스 메서드가 인스턴스 변수를 사용한다.
      + 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다. (다른언어의 경우 제일 아래 선언하는 경우도 있다.)
    * 종속 함수
      + 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
      + 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
      + 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로 상수를 넘겨주는 방법이 더 좋다.
    * 개념적 유사성
      + 어떤 코드는 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다. 친화도가 높을수록 코드를 가까이 배치한다.
      + 한 함수가 다른 함수를 호출해 생기는 직접적인 종속성
      + 변수와 그 변수를 사용하는 함수
      + 비슷한 동작을 수행하는 일군의 함수
    * 세로 순서
      + 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
      + 호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.
  - 가로 형식 맞추기
    * 프로그래머는 명백하게 짧은 행을 선호한다.
    * 120자 정도로 행길이를 제한 하는 것이 좋다.
  - 가로 공백과 밀집도
    * 가로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
    * 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해 진다.
    * 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 떄문이다.
    * 공백을 넣으면 한 개념이 아니라 별개로 보인다.
    * 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리했다.
    * 연산자 우선 순위를 강조하기 위해서도 공백을 사용한다.
  - 가로 정렬
    * 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 나리다.
    * 선언부가 길다면 클래스를 쪼개야 한다.
  - 들여쓰기
    * 소스파일은 윤곽도(Outline)와 계층이 비슷하다.
    * 범위로 이뤄진 계층을 표현하기 위해 우리는 코드를 들여쓴다.
    * 클래스 정의처럼 파일 수준인 문장은 들여쓰지 않는다.
    * 클래스 내 메서드는 클래스보다 한 수준 들여쓴다.
    * 메서드 코드는 메서드 선언보다 한 수준 들여쓴다.
    * 블록 코드는 블록을 포함하는 코드보다 한 수준 들여쓴다.
    * 왼쪽으로 코드를 맞춰 보드가 속하는 범위를 시각적으로 표현한다.
    * 들여쓰기 무시하기
      + 간단한 if문, while문, 짧은 함수에서도 들여쓰기 규칙을 무시하면 안된다.
    * 가짜 범위
      + 세미콜론(;)을 새 행에다 제대로 들여써서 넣어준다.
      + 가독성이 높아 구분하기 쉽다.
  - 팀규칙
    * 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다.
    * 소프트웨어가 일관적인 스타일을 가져야 한다.
    * 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사실을 기억하기 바란다.
    * 스타일은 일관적이고 매끄러워야 한다.
    * 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다.
