클린 코드 - 01 깨끗한 코드
=============================

> 도서 : Clean Code(클린 코드)애자일 소프트웨어 장인 정신
> 저자 : 로버트 C. 마틴

1. 깨끗 한 코드
  - 비야네.스트룹
    * 의존성을 최대한 줄여야 한다.
    * 깨끗한 코드는 한 가지를 제대로 한다.
  - 그래디 부치
    * 의미있는 이름이 붙는다.
  - 데이브 토마스
    * 잘 쓴 문장처럼 읽힌다.
  - 마이클 페더스
    * 주의깊게 짰다는 느낌이다.
  - 론 제프리
    * 중복을 피해라.
    * 한 기능만 수행하라.
    * 제대로 표현하라.
    * 작게 추상화 하라
  - 개발자는 코드를 작성하는 시간보다 읽는 시간이 월등히 길다.
  - 보이스카웃 규칙
    * "캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라"

2. 의미 있는 이름
  -  의도를 분명히 밝혀라.
    * 존재이유, 수행기능, 사용방법이 드러나야 한다.
  - 그릇된 정보를 피해라.
    * 유사한 개념은 유사한 표기법을 사용한다.
    * 일관성이 떨어지는 표기법은 그릇된 정보다.
  - 의미있게 구분하라.
    * 이름이 달라야 한다면, 의미도 달라야 한다.
    * 읽는 사람이 차이를 알도록 이름을 지어라.
  - 발음하기 쉬운 이름을 사용하라.
    * 공유 가능한 이름을 사랑한다.
  - 검색하기 쉬운 이름을 사용하라.
    * 이름 길이는 범위 크기에 비례해야 한다.
  - 인코딩을 피해라.
    * 문제해결에 집중하는 개발자에게 인코딩은 불필요한 정신적 부담이다.
  - 자신의 기억력을 자랑하지 마라
    * 문자 하나만 쓰는 변수는 작은 루프의 반복 횟수를 세는 변수에만 사용해라. (i, j 등)
    * "명료함이 최고다"
  - 클래스 이름
    * 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
  - 메서드 이름
    * 메서드명은 동사나 동사구가 적합하다.
    * 생성자를 중복정의 할 때는 정적 팩토리 메서드를 사용한다.
  - 한 개념에 한 단어를 사용하라.
    * 일관성 있는 어휘코드를 사용하라.
  - 말장난을 하지마라
    * 다른 개념에 같은 단어를 사용하지 마라
    * 의미를 해독 할 책임이 독자에 있는 논문 모델이 아니라, 의도를 밝힐 책임이 저자에 있는 잡지 모델이 바람직하다.
  - 해법영역에서 가져온 이름을 사용하라.
    * 코드를 읽는 사람도 개발자다.
    * 전산용어, 알고리즘 이름, 패턴명, 수학 용어 등을 사용해라.
  - 문제영역에서 가져온 이름을 사용하라.
    * 적절한 프로그래머용어가 없으면, 문제 영역에서 이름을 가져와라.
    * 문제영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.
  - 의미있는 맥락을 추가하라.(접두어 등)
    * 함수 이름은 맥락일부만 제공하며, 알고리즘이 나머지 맥락을 제공한다.
    * 맥락을 개선하면 함수 쪼개기가 쉬워지므로 알고리즘도 더 명확해진다.
  - 불필요한 맥락을 없애라.
    * 일반적으로 짧은 이름이 긴 이름보다 좋다.
    * 이름에 불필요한 맥락을 추가하지 않도록 주의한다.

3. 함수
  - 어떤 프로그램이든 가장 기본적인 단위가 함수다.
  - 작게 만들어라.
    * 함수를 만드는 첫째 규칙은 '작게''다. 함수를 만드는 둘째 규칙은 '더 작게'다.
    * if/else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
  - 한 가지만 해라.
    * 함수는 한가지를 해야한다. 그리고 그 한가지를 잘해야 한다. 그 한가지만을 해야만 한다.
    * 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한가지 작업만 한다.
    * 단순히 다른 표현이 아니라, 의미있는 이름으로 다른 함수를 추출 할 수 있다면 그 함수는 여러작업을 하는 셈이다.
  - 함수당 추상화 수준은 하나로.
    * 함수가 확실히 '한 가지' 작업만 하려면 함수내 모든 문장의 추상화 수준이 동일 해야 한다.
    * 내려가기 규칙 : 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아 진다.
  - switch문
    * switch문은 작게 만들기 어렵다.
    * 다형성을 이용하여 switch문을 저차원 클래스에 숨기고 절대 반복하지 않는 방법이 있다.
  - 서술적인 이름을 사용하라.
    * 이름이 길어도 괜찮다.
    * 길고 서술적인 이름이 길고 서술적인 주석보다 낫다.
    * 이름을 붙일때는 일관성이 있어야 한다. 모듈내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
  - 함수인수
    * 함수에서 이상적인 인수의 개수는 0개(무항)이다.
    * 4개 이상의 다항은 사용하면 안된다.
    * 최선은 입력인수가 없는 경우이며, 차선은 입력 인수가 하나인 겨우이다.
    * 많이 쓰는 다항 형식
      + 인수에 질문을 던지는 경우
      + 인수를 뭔가로 변환해 결과를 반환하는 경우
      + 이외의 경우는 단항 함수를 가급적 피한다.
    * 플래그인수
      + 함수가 한꺼번에 여러가지 일을 한다.
    * 인수객체
      + 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
  - 부수효과를 일으키지마라
  - 명령과 조회를 분리하라.
   * 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
  - 오류코드보다 예외를 사용하라.
    * 오류처리도 한가지 작업이다.
  - 반복하지 마라
    * 중복은 소프트웨어에서 모든 악의 근원이다.
    * 객체지향 프로그래밍은 코드를 부모클래스로 몰아 중복을 없앤다.
  - 구조적 프로그래밍
    * 데이크스트 왈 "모든 함수와 함수내 모든 블록에 입구와 출구가 하마나만 존재해야 한다."
  - 함수는 그언어에서 동사며 클래스는 명사이다.

4. 주석
  - "나쁜 코드에 주석을 달지 마라, 새로짜라" - 플라우거
  - 잘 달린 주석은 그어떤 정보보다 유용하다.
  - 주석은 오래될수록 코드에서 멀어진다.
  - 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하다.
    * 코드의 복사, 수정 등을 진행할 때 코드는 관리가 되지만 주석은 관리된다는 보장이 없다.
  - 주석은 나쁜 코드를 보완하지 못한다.
    * 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
  - 코드로 의도를 표현하라!
    * 코드로 대다수 의도를 표현할 수 있다.
  - 좋은 주석
    * 법적인 주석
      + 각 소스 파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하고도 타당하다.
    * 정보를 제공하는 주석
      + 정규표현식의 설명 등
    * 의도를 설명하는 주석
      + 때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.
    * 의미를 명료하게 밝히는 주석
      + 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다.
      + 주석이 올바른지 검증하기 쉽지 않으므로 각별히 주의한다.
    * 결과를 경고하는 주석
      + "//여유시간이 충분하지 않다면 실행하지 마십시오"와 같은 주석은 좋다.
      + 테스트코드의 경우 "@Ignore"를 사용해서 주석을 단다.
    * TODO 주석
      + 때로는 '앞으로 할 일'을 //TODO 주석으로 남겨두면 편하다.
      + 주기적으로 TODO주석을 점검해 없애도 괜찮은 주석은 없애라고 권한다.
    * 중요성을 강조하는 주석
    * 공개 API에서 JavaDocs
      + 공개 API를 구현한다면 반드시 훌륭한 JavaDocs를 작성한다.
  - 나쁜 주석
    * 대다수 주석이 이 범주에 속한다.
    * 주절거리는 주석
      + 주석을 달기로 결정 했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.
    * 같은 이야기를 반복하는 주석
      + 자칫하면 코드보다 주석을 읽는 시간이 더 오래걸린다.
    * 오해할 여지가 있는 주석
    * 의무적으로 다는 주석
      + 모든 함수에 주석을 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석다.
      + 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며, 잘못된 정보를 제공할 여지만 만든다.
      + 소스코드관리시스템이 있으므로 따로 이력을 남길 필요가 없다.
    * 있으나 마나 한 주석
      + 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석은 기록하지 마라
      + 잇으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리하라.
    * 무서운 잡음
    * 함수나 변수로 표현 할 수 있다면 주석을 달지마라.
    * 위치를 표시하는 주석
      + 너무 자주 사용하지 않는다면 배너는 눈에 띄며 주의를 환기한다. 그러므로 반드시 필요할 때만, 아주 드말게 사용하는것이 좋다.
    * 닫는 괄호에 다는 주석
      + 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자.
    * 공로를 돌리거나 저자를 표시하는 주석
      + 이력에 관한 정보는 소스코드 관리 시스템에 저장하는 편이 좋다.
    * 주석으로 처리한 코드
      + 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어서 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다.
    * 전역정보
      + 주석을 달아야 한다면 근처에 잇는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라.
    * 너무 많은 정보
      + 주석에다 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라.
    * 모호한 관계
      + 주석과 주석이 설명하는 코드는 둘 사이에 관계가 명백해야 한다.
      + 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다.
    * 함수 헤더
      + 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.
    * 비공개 코드에서의 JavaDocs
      + 시스템 내부에 속한 클래스와 함수에 JavaDocs를 생성할 필요는 없다.

5. 형식 맞추기
  - 형식을 맞추는 목적
    * 코드 형식은 의사소통의 일환이다. 의사소통은 전문개발자의 일차적인 의무이다.
    * 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.
  - 적절한 행 길이를 유지하라.
    * 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다.
    * 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.
  - 신문기사처럼 작성하라
    * 소스파일도 신문기사와 비슷하게 작성한다.
      + 이름은 간단하면서도 설명이 가능하게 짓는다.
      + 소스파일 첫 부분은 고차원 개념과 알고리즘을 설명한다.
      + 아래로 내려갈수록 의도를 세세하게 묘사한다.
      + 마지막에는 가장 저차원 함수와 세부내역이 나온다.
  - 개념은 빈 행으로 분리하라
    * 빈 행은 새로운 개념을 시작한다는 시각적 단서다.
  - 세로 밀집도
    * 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다.
    * 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.
  - 수직거리
    * 서로 밀접한 개념은 세로로 가까이 둬야 한다. 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.
    * 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다.
    * 변수선언
      + 변수는 사용하는 위치에 최대한 가까이 선언한다.
      + 짧은 함수의 경우 지역변수는 각 함수 맨 처음에 위치한다.
    * 인스턴스 변수
      + 인스턴스 변수는 클래스 맨 처음에 선언한다. 변수간에 세로로 거리를 두지 않는다.
      + 잘 설계한 클래스는 많은 클래스 메서드가 인스턴스 변수를 사용한다.
      + 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다. (다른언어의 경우 제일 아래 선언하는 경우도 있다.)
    * 종속 함수
      + 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
      + 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
      + 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로 상수를 넘겨주는 방법이 더 좋다.
    * 개념적 유사성
      + 어떤 코드는 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다. 친화도가 높을수록 코드를 가까이 배치한다.
      + 한 함수가 다른 함수를 호출해 생기는 직접적인 종속성
      + 변수와 그 변수를 사용하는 함수
      + 비슷한 동작을 수행하는 일군의 함수
    * 세로 순서
      + 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
      + 호출되는 함수를 호출하는 함수보다 나중에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.
  - 가로 형식 맞추기
    * 프로그래머는 명백하게 짧은 행을 선호한다.
    * 120자 정도로 행길이를 제한 하는 것이 좋다.
  - 가로 공백과 밀집도
    * 가로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
    * 공백을 넣으면 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해 진다.
    * 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 떄문이다.
    * 공백을 넣으면 한 개념이 아니라 별개로 보인다.
    * 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리했다.
    * 연산자 우선 순위를 강조하기 위해서도 공백을 사용한다.
  - 가로 정렬
    * 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 나리다.
    * 선언부가 길다면 클래스를 쪼개야 한다.
  - 들여쓰기
    * 소스파일은 윤곽도(Outline)와 계층이 비슷하다.
    * 범위로 이뤄진 계층을 표현하기 위해 우리는 코드를 들여쓴다.
    * 클래스 정의처럼 파일 수준인 문장은 들여쓰지 않는다.
    * 클래스 내 메서드는 클래스보다 한 수준 들여쓴다.
    * 메서드 코드는 메서드 선언보다 한 수준 들여쓴다.
    * 블록 코드는 블록을 포함하는 코드보다 한 수준 들여쓴다.
    * 왼쪽으로 코드를 맞춰 보드가 속하는 범위를 시각적으로 표현한다.
    * 들여쓰기 무시하기
      + 간단한 if문, while문, 짧은 함수에서도 들여쓰기 규칙을 무시하면 안된다.
    * 가짜 범위
      + 세미콜론(;)을 새 행에다 제대로 들여써서 넣어준다.
      + 가독성이 높아 구분하기 쉽다.
  - 팀규칙
    * 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다.
    * 소프트웨어가 일관적인 스타일을 가져야 한다.
    * 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사실을 기억하기 바란다.
    * 스타일은 일관적이고 매끄러워야 한다.
    * 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다.

6. 객체와 자료 구조
  - 변수를 비공개로 정의하는 이유는 남들이 변수에 의존하지 않게 만들기 위해서다.
  - 자료 추상화
    * 조회는 각각, 세팅은 한 번에
      + 좌표를 읽을 때는 각 값을 개별적으로 읽어야한다.
      + 좌표를 설정 할 때는 두 값을 한번에 해야한다.
    * 인터페이스는 자료 구조를 명확하게 표현한다.
    * 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않는다.
    * 구현을 감추려면 추상화가 필요하다.
      + 조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되지는 않는다.
    * 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
    * 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.
    * 인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다.
    * 아무 생각 없이 조회/설정 함수를 추가 하는 방법이 가장 나쁘다.
  - 자료/객체 비대칭
    * 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
    * 자료구조는 자료를 그대로 공개하며 별다른 함수를 제공하지 않는다.
    * 객체 지향 코드에서 어련운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.
      + 새로운 타입 : 클래스와 객체지향기법이 적합
      + 새로운 함수 : 절차적인 코드와 자료구조가 적합
  - 디미터 법칙
    * 디미터 법칙은 잘 알려진 휴리스틱으로 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
    * 객체는 조회 함수로 내부구조를 공개하면 안된다는 의미이다.
    * 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출 하면 안된다.
      + 이런 호출을 '기차 충돌'이라고 한다.
    * 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면 자료구조라면 당연히 내부구조를 노출 하므로 디미터 법칙이 적용되지 않는다.
    * 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면, 문제는 훨씬 간단하다. 하지만 단순한 자료 구조에도 조회 함수와 설정함수를 정의하라 요구하는 프레임워크와 표준(Bean)이 존재한다.
  - 잡종 구조
    * 절반은 객체, 절반은 자료 구조인 잡종 구조가 있다.
    * 중요한 기능을 수행하는 함수도 있고, 공개변수나 공개 조회/설정 함수도 있다.
    * 공개 조회/설정 함수는 비공개 변수를 그대로 노출한다.
  - 구조체 감추기
    * 객체라면 내부 구조를 감춰야 한다.
  - 자료 전달 객체
    * 자료 구조체이 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다.
    * 자료 구조체를 때로는 자료 전달 객체(DTO)라고 한다.
    * DTO는 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석 할 때 유용하다.
    * DTO는 데이터 베이스에 저장된 가공 되지 않은 정보를 애플리케이션 코드에서 사용 할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체다.
  - 활성 레코드
    * 활성레코드는 DTO의 특수한 형태이다.
    * 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 가료구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다.
    * 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.
    * 비지니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하다. 하지만 이는 바람직하지 않다.
    * 활성 레코드는 자료구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.
      + 여기서 내부자료는 활성 레코드의 인스턴스일 가능성이 높다.
  - 결론
    * 객체는 동작을 공개하고 자료를 숨긴다.
      + 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.
    * 자료구조는 별다른 동작 없이 자료를 노출한다.
      + 기존 자료 구조에 새동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
    * 새로운 자료 타입 추가가 잦으면 객체를 사용
    * 새로운 동작 추가가 잦으면 자료구조와 절차적인 코드를 사용

7. 오류처리
  - 오류 코드보다 예외를 사용하라.
    * 비즈니스 알고리즘과 오류를 처리하는 알고리즘을 분리해라.
  - Try-Catch-Finally문 부터 작성하라.
    * Try-Catch-Finally문에서 Try블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 Catch블록으로 넘어갈 수 있다.
    * Try블록은 트랜잭션과 비슷하다. Try 블록에서 무슨 일이 생기든지 Catch블록은 프로그램 상태를 일관성 있게 유지해야 한다.
  - 미확인(unchecked) 예외를 사용하라.
    * checked 예외는 컴파일 단계에서 확인되며 반드시 처리해야 하는 예외입니다.
    * Unchecked 예외 는 실행 단계에서 확인되며 명시적인 처리를 강제하지는 않는 예외입니다.
    * OCP위반 : 확인된 예외는 예상되는 모든 예외를 사전에 처리할 수 있다는 장점이 있지만, 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 더 크다.
    * 메서드를 선언할 때 메서드가 반환할 예외를 모두 열거해야 하기 때문에 메서드 유형의 일부가 됨
  - 에외에 의미를 제공하라.
    * 예외를 던질 때는 전후 상황을 충분히 덧붙인다.
    * 오류 메시지에 정보를 담아 예외와 함께 던진다.
    * 실패한 연산 이름과 실패 유형도 언급한다.
    * 애플리케이션이 로깅 가능하도록 Catch블록에서 오류에 관한 충분한 정보를 넘겨준다.
  - 호출자를 고려해 예외 클래스를 정의하라.
    * 애플리케이션에서 오류를 정의 할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
    * 외부API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다.
      + 라이브러리 변경이 쉽다.
  - 정상 흐름을 정의하라.
    * 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식을 특수 사례 패턴이라고 한다.
  - null을 반환하지 마라
    * null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.
  - null을 전달하지 마라
    * 메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
    * null을 넘기지 못하도록 금지하는 정책이 합리적이다.
  - 결론
    * 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
    * 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지 보수성도 크게 높아진다.

8. 경계
  - 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드믈다.
  - 외부 코드 사용하기
    * Map은 굉장히 다양한 인터페이스로 수많은 기느을 제공한다.
    * Map이 제공하는 기능성과 유연성은 확실히 유용하지만 그만큼 위험도 크다.
    * 제네닉스(Generics)를 사용하면 코드 가독성이 크게 높아진다.
      + Map<String, sensor> map = new HashMap();을 쓰는것 보다
      + 조회 메서드에 return (sensor)sensors.get(id);이런식으로 쓰는것을 추천한다.
      + 사용자는 제네릭스가 사용되었는지 여부에 신경쓸 필요가 없다.
      + 제네릭스의 사용여부는 Sensors안에서 결정한다.
  - 경계 살피고 익히기
    * 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부코드를 익히는 것을 학습테스트라고 부른다.(짐 뉴커크)
  - 학습 테스트는 공짜 이상이다.
    * 패키지 새 버전이 나올때마다 새로운 위험이 생긴다.
    * 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.
  - 아직 존재하지 않는 코드를 사용하기
    * 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.
    * 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다.
    * 또한 코드 가독성도 높아지고 코드 의도도 분명해진다.
  - 깨끗한 경계
    * 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.
    * 통제가 불가능한 외부패키지에 의존하는 대신 통제가 가능한 우리코드에 의존하는 편이 훨씬 좋다.
    * 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
    * 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
    * 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 떄 변경할 코드도 줄어든다.

9. 단위 테스트
  - TDD 법칙 세 가지
    * 첫째 법칙 : 실패하는 단위 테스트를 작성할 떄까지 실제 코드를 작성하지 않는다.
    * 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성 한다.
    * 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
  - 깨끗한 테스트 코드 유지하기
    * 테스트 코드는 실제 코드 못지 않게 중요하다.
    * 실제 코드 못지 않게 깨끗하게 짜야 한다.
    * 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
      + 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다.
      + 테스트 케이스가 있으면 변경이 쉬워진다.
      + 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다.
  - 깨끗한 테스트 코드
    * 깨끗한 테스트 코드를 만들려면 가독성이 중요하다.
      + 어쩌면 가독성은 실제 코드보다 테스트 코드가 더더욱 중요하다.
    * 각 테스트는 세 부분으로 나눠진다.
      + given : 테스트 자료를 만든다.
      + when : 테스트 자료를 조작한다.
      + then : 조작 결과가 올바른지 확인한다.
    * 도메인에 특화된 테스트 언어
      + 함수와 유틸리티는 테스트 코드에서 사용하는 특수 API가 된다.
      + 즉, 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다.
    * 이중 표준
      + 테스트 API코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다.
      + 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드 만큼 효율적일 필요는 없다.
  - 테스트 당 assert 하나
    * JUnit으로 테스트 코드를 짤 때는 함수마다 assert문을 단 하나만 사용해야 한다.
      + 단일 assert문을 사용하려고 노력해야 한다. 최소한으로 줄여야 한다.
    * given-when-then기법은 Template Method패턴을 사용하면 중복을 제거 할 수 있다.
      + given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다.
    * 테스트 당 개념 하나
      + 테스트 함수마다 한 개념만 테스트 하라.
      + 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다.
      + 가장 좋은 규칙은 "개념당 assert문 수를 최소로 줄여라"와 "테스트 함수 하나는 개념 하나만 테스트하라"이다.
  - F.I.R.S.T
    * 깨끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 First가 된다.
      + 빠르게 Fast : 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리자 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.
      + 독립적으로 Independent : 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
      + 반복 가능하게 Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경 QA 환경, 버스를 타고 집으로 가는 길에 사용하는 (네트워크에 연결되지 않은) 노트북 환경에서도 실행할 수 있어야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.
      + 자가검증하는 Self-Validating : 테스트는 부울 값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다. 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.
      + 적시에 Timely : 테스트는 적시에 작성해야 한다. 단위테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 실제코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제코드를 설게할지도 모른다.

10. 클래스
  - 클래스 체계
    * 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다. 정적 공개 상수가 있따면 맨처음에 나온다. 다음으로 정적 비공개 변수가 나오며, 이어서 비공개 인스턴스 변수가 나온다. 공개 변수가 필요한 경우는 거의 없다.
    * 변수 목록 다음에는 공개 함수가 나온다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다. 그래서 프로그램은 신문 기사처럼 읽는다.
  - 캡슐화
    * 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다. 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다. 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.
  - 클래스는 작아야 한다.
    * 클래스를 설계 할때도 함수와 마찬가지로, "작게"가 기본 규칙이라는 의미다.
    * 클래스의 이름은 해당 클래스 책임을 기술해야 한다.
    * 클래스 설명은 만일(if), 그리고(and), -(하)며(or), 하지만(but)을 사용하지 않고서 25단어 내외로 가능해야 한다.
    * 단일 책임 원칙
      + 단일 책임 원칙(Single Responsibility Principle)은 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.
      + 클래스는 책임, 즉 변경 할 이유가 하나여야 한다.
      + 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 더 좋은 추상화 가 더 쉽게 떠오른다.
      + 많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이애하기 어려워진다고 우려한다.
      + 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
      + 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.
    * 응집도
      + 일반적으로 이처럼 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않다.
      + 우리는 응집도가 높은 클래스를 선호한다. 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다.
      + 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.
    * 응집도를 유지하며 작은 클래스 여럿이 나온다.
      + 클래스가 응집력을 잃는다면 쪼개라.
      + 작은 함수와 클래스로 나눈 후 함수와 클래스와 변수에 좀 더 의미 있는 이름을 부여해야 한다.
      + 첫째, 리팩터링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용한다.
      + 둘째, 리팩터링한 프로그램은 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용한다.
      + 셋째, 가독성을 높이고자 공백을 추가하고 형식을 맞추었다.
  - 변경하기 쉬운 클래스
    * 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.
    * 객체 지향 설계에서 또 다른 핵심 원칙인 OCP(Open-Closed Principle)도 지원한다.
      + OCP란 클래스는 확장에 개방적이고 수정에 폐쇄적이어야한다는 원칙이다.
      + 파생 클래스를 생성하는 방식으로 새 기능에 개방적인 동시에 다른 클래스를 닫아놓은 방식으로 수정에 폐쇄적이다.
    * 변경으로부터 격리
      + 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
      + 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.
      + 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.
      + 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP(Dependency Inversion Principle)를 따르는 클래스가 나온다.
      + 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

11. 시스템
  - 도시를 세운다면?
    * 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.
    * 높은 추상화 수준, 즉 시스템 수준에서도 꺠끗함을 유지해야 한다.
  - 시스템 제작과 시스템 사용을 분리하라.
    * 제작(Construction)은 상용(use)과 우주 다르다는 사실을 명심한다.
    * 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
    * 시작 단계는 모든 애플리케이션이 풀어야 할 관심사(concern)다.
    * 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.
    * 초기화 지연 / 계산 지연 기법
      + 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.
      + 애플리케이션을 시작하는 시간이 그만큼 빨라진다.
      + 어떤 경우에도 null포인터를 반환하지 않는다.
      + `if(service == null) {
          service = new MyServiceImpl(...);
          return service;
        }`
    * 체계적이고 탄탄한 시스템을 만들고 싶다면 흔희 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대 안 된다.
    * 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.
  - main 분리
  - 팩토리
  - 의존성 주입
    * 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입(Dependency Injection)이다.
    * 의존성 주입은 제어 역전(IoC)기법을 의존성 관리에 적용한 메커니즘이다.
    * 제어역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.
    * 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙(SRP)을 지키게 된다.
    * 의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다.
    * 초기 설정은 시스템 전체에서 필요하므로 대게 '책임질' 메커니즘으로 'main'루틴이나 특수 컨테이너를 사용한다.
    * 스프링 프레임워크는 가장 널리 알려진 자바 DI 컨테이너를 제공한다.
    * 대다수 DI컨테이너는 피룡할 때까지는 객체를 생성하지 않고, 대부분은 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다.
    * 계산 지연기법이나 이와 유사한 최적화 기법에서 이런 메커니즘을 사용할 수 있다.
  - 확장
    * 테스트 주도개발(TDD), 리펙터링, (TDD와 리팩터링으로 얻어지는) 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
    * 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리 한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.
    * 횡단 관심사
      + 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다.
      + 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다.
      + 특정 DBMS나 독자적인 파일을 사용하고, 테이블과 열은 같은 명명 관례를 따르며, 트랜잭션 의미가 일괄적이면 더욱 바람직하다.
      + AOP에서 관점이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일괄성있게 바꿔야 한다."라고 명시한다.
      + 명시는 간결한 선언이나 프로그래밍 메커니즘으로 수행한다.
  - 자바 프록시
    * 일반적으로 프록시는 다른 무언가와 이어지는 인터페이스의 역할을 하는 클래스이다. 프록시는 어떠한 것(이를테면 네트워크 연결, 메모리 안의 커다란 객체, 파일, 또 복제할 수 없거나 수요가 많은 리소스)과도 인터페이스의 역할을 수행할 수 있다.
  - 순수 자바 AOP 프레임워크
    * POJO는 순수하게 도메인에 초점을 맞춘다.
    * 애너테이션에 들어있는 영속성 정보는 일부든 전부든, 필요하더면, XML 배치 기술자로 옮겨도 괜찮다. 그러면 진짜 순수한 POJO만 남는다.
  - AspectJ 관점
    * AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
  - 테스트 주도 시스템 아키텍처 구축
    * 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 지정한 테스트 주도 아키텍처 구축이 가능해진다.
    * BDUF (Big Design Up Front) : 구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법이다.
    * 최선의 시스템 구조는 각기 POJO(또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.
  - 의사 결정을 최적화하라
    * 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다 .
    * 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기 쉬워진다. 또한 결정의 복잡성도 줄어든다.
  - 명백한 가치가 있을 때 표준을 현명하게 사용하라
    * 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경혐을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.
  - 시스템은 도메인 특화 언어가 필요하다.
    * DSL(Domain-Specific Language)은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다.
    * 좋은 DSL은 도메인 개념과 그 개념을 구현한 콛 사이에 존재하는 '의사소통 간극'을 줄여준다.
  - 결론
    * 시스템 역시 꺠끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다. 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야한다.
    * 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.

12. 창발성
  - 창발성 : 조직(organization)의 일정수준에서 실체에 속한 성질은 그보다 낮은 차원에서 발견된 성질로부터는 예견할 수 없다.
  - 창발적 설계로 깔끔한 코드를 구현하자.
    * 켄트 벡은 다음 4가지 규칙을 따르는 설계는 '단순하다'고 말한다.
      + 모든 테스트를 실행한다.
      + 중복을 없앤다.
      + 프로그래머의 의도를 표현한다.
      + 클래스와 메서드 수를 최소로 줄인다.
  - 단순한 설계 규칙 1 :모든 테스트를 실행하라.
    * 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.
    * 테스트가 불가능한 시스템은 검증도 불가능 하다.
    * 결합도가 높으면 테스트 케이스를 작성하기 어렵다.
    * '테스트 케이스를 만들고 계속 돌려라'라는 간단하고 단순한 규칙을 따르면 시스템은 낮은 결합도와 높은 응집력이라는, 객체 지향 방법론이 지향하는 목표를 저절로 달성한다.
  - 단순한 설계 규칙 2~4 : 리펙터링
    * 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있으니까!
    * 리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다.
    * 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고 더 나은 이름을 선택하는 등 다양한 기법을 동원해라.
  - 중복을 없애라.
    * 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문이다.
    * 똑같은 코드나 구현중복도 한 형태이다.
    * '소규모 재사용'은 시스템 복잡도를 극적으로 줄여준다.
  - 표현하라
    1. 좋은 이름을 선택한다.
    2. 함수와 클래스 크기를 가능한 줄인다.
    3. 표준 명칭을 사용한다.
    4. 단위 테스트 케이스를 꼼꼼히 작성한다.
  - 클래스와 메서드 수를 최소로 줄여라.
    * 목표는 함수와 클래스 크기를 작게 유지하면서. 동시에 시스템 크기도 작게 유지하는데 있다.
    * 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업은 더 중요하다는 뜻이다.

13. 동시성
  - 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
  - 동시성이 필요한 이유?
    * 동시성은 결합을 없애는 전략이다.
    * 무엇과 언제를 분리하는 전략이다.
      + 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
    * 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 돌아간다.
    * 동시성
      + 동시성은 다소 부하를 유발한다.
      + 동시성은 복잡하다.
      + 일반적으로 동시성 버그는 재현하기 어렵다.
      + 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.
  - 동시성 방어 원칙
    * 단일 책임 원칙 SRP
      + SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
      + 동시성관련 코드는 다른 코드와 분리해야 한다는 뜻이다.
    * 동시성 구현시 고려사항
      + 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
      + 동시성 코드에는 독자적인 난관이 있다.
      + 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.
    * 동시성 코드는 다른 코드와 분리하라.
    * 자료 범위를 제한하라.
      + 공유객체를 사용하는 코드 내 임계 영역을 synchronized 키워드로 보호하라고 권장한다.
      + 자료를 캐슐화하라. 공유 자료를 최대한 줄여라 .
    * 자료 사본을 사용하라.
      + 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
    * 스레드는 가능한 독립적으로 구현하라.
      + 다른 스레드와 자료를 공유하지 않는다.
      + 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할 하라.
  - 라이브러리를 이해하라.
    * 스레드 환경에 안전한 컬렉션
      + ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다. 동시 읽기/쓰기를 지원하며, (보통 다중 스레드 환경에서 문제가 생기는) 자주 사용하는 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공한다.
      + 언어가 제공하는 클래스를 검토하라.
  - 실행모델을 이해하라.
    * 한정된 자원 : 다중스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 일기/쓰기 버퍼 등이 예다.
    * 상호 배제 : 한 번에 한 스레드만 공유자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
    * 기아 : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
    * 데드락 : 여러 스레드가 서로 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 진행 하지 못한다.
    * 라이브락 : 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행 하려하지만, 공명으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.
    * 생산자 - 소비자
      + 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
      + 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
      + 생산자 스레드와 소비자 스레드가 사요하는 대기열은 한정된 자원이다.
  - 동기화하는 메서드 사이에 존재하는 의존성을 이해하라.
    * 공유 객체 하나에는 메서드 하나만 사용하라.
    * 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그럴떄는 다음 세가지를 고려하라.
      + 클라이언트에서 잠금
      + 서버에서 잠금
      + 연결 서버
  - 동기화 하는 부분을 작게 만들어라.
    * 동기화 하는 부분을 최대한 작게 만들어라.
  - 올바른 종료 코드는 구현하기 어렵다.
    * 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라.
    * 생각보다 오래걸린다.
    * 이미 나온 알고리즘을 컴토하라.
  - 스레드 코드 테스트하기
    * 문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절되 안 된다.
    * 구체적인 지침
      + 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라.
        - 실패를 재현하기가 아주 어렵다.
        - 시스템 실패를 '일회성'이라 치부하지 마라.
      + 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
        - 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅 하지 마라.
      + 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라.
        - 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.
      + 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
      + 프로세서 수보다 많은 스레드를 돌려 보라.
      + 다른플렛폼에서 돌려보라.
        - 처음부터 그리고 자주 모든 목표 플렛폼에서 코드를 돌려라.
      + 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.
        - 흔들기 기법을 사용해 오류를 찾아내라.
  - 결론
    * SRP를 준수한다.
    * POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리한다.
    * 스레드 코드를 테스트할때는 전적으로 스레드만 테스트 한다.
    * 스레드 코드는 최대한 집약되고 작아야 한다는 의미다.
