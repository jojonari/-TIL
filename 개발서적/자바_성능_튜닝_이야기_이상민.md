자바 성능 튜닝 이야기
=============================

> 도서 : 개발자가 반드시 알아야 할 자바 성능 튜닝 이야기
> 저자 : 이상민

1. 디자인 패턴은 꼭 써야 한다
  - MVC 패턴 : 뷰는 이벤트를 발생시키고 이벤트의 결과를 보여주는 역할, 모델은 뷰에서 입력된 내용을 저장, 관리, 수정하는 역할, 컨트롤러는 뷰와 모델의 연결자 역할이라고 생각하면 된다.
  - design pattern : 시스템을 만들기 위해서 전체 중 일부 의미 있는 클래스들을 묶은 각각의 집합을 디자인 패턴이라고 생각하면 된다.
    + 반복되는 의미 있는 집합을 정의하고 이름을 지정해서, 누가 이야기 하더라도 동일한 의미의 패턴이 되도록 만들어 놓은 것이다.
  - 꼭 알아야 할 기본적이고 실용적인 패턴
    + Business Delegate : 비지니스 서비스 접근을 캡슐화하는 패턴이다.
    + Service Locator : 서비스와 컴포넌트 검색을 쉽게 하는 패턴
    + Session Facade : 비지니스 티어 컴포넌트를 캡슐화하고, 원격 클라이언트에서 접근할 수 있는 서비스를 제공하는 패턴이다.
    + Transfer Object : 일명 Value Object 패턴이라고 많이 알려져 있다. 데이터를 전송하기 위한 객체에 대한 패턴이다.
    + Data Access Object :  일명 DAO라고 많이 알려져 있다. DB에 접근을 전담하는 클래스를 추상화하고 캡슐화 한다.
  - Serializable 인터페이스를 구현하면 객체를 직렬화할 수가 있다. 다시 말해 서버 사이의 데이터 전송이 가능해진다.

2. 내가 만든 프로그램의 속도를 알고 싶다.
  - 프로파일링 툴은 개발자용 툴이고, APM툴은 운영 환경용 툴이다.
  - 프로파일링 툴
    + 소스레벨의 분석을 위한 툴이다. (개발시 느린 메서드, 느린 클래스를 찾는 것을 주 목적으로 한다.)
    + 애플리 케이션의 세부 응답 시간까지 분석할 수 있다.
    + 메모리 사용량을 객체나 클래스, 소스의 라인 단위까지 분석할 수 있다.
    + 자바 기반의 클라이언트 프로그램 분석을 할 수 있다.
  - APM 툴
    + 애플리케이션의 장애 상황에 대한 모니터링 및 문제점 진단이 주 목적이다.
    + 서버의 사용자수나 리소스에 대한 모니터링을 할 수 있다.
    + 실시간 모니터링을 위한 툴이다.
    + 자바 기반의 클라이언트 프로그램 분석이 불가능하다.
  - Clock time : cpu 사용시간과 대기시간을 더한 실제 소요시간
  - JVM에서 사용할 수 있는 설정은 크게 두가지로 나뉜다.
    + 속성(property) : JVM에서 지정된 값들
    + 환경(Environment) : 장비(서버)에 지정되어 있는 값들 (흔히 env라고 한다.)
  - System.class의 절대 사용하면 안되는 메서드
    + gc() : 자바에서 사용하는 메모리를 명시적으로 해제하도록 GC를 수행하는 메서드
    + exit(int status) : 현재 수행중인 자바VM을 멈춘다.
    + runFinalization() : 가비지 콜렉터가 알아서 호출하는 finalize()를 수동으로 호출 해야 참조 해제 작업을 수행한다. (GC가 제대로 안된다.)

3. 왜 자꾸 String을 쓰지 말라는 거야.
  - 여러 이터레이션(iteration)에 걸쳐서 개발한다는 말은 하나의 프로젝트를 여러 차수에 걸쳐서 개발하는 방식이다.
  - StringBuffer 클래스는 스레드에 안전하게 설계되어 있으므로, 여러 개의 스레드에서 하나의 StringBuffer 객체를 처리해도 전혀 문제가 되지 않는다. 하지만 StringBuilder는 단일스레드에서의 안전성만을 보장한다.
  - 속도 테스트 결과
    + String은 짧은 문자열을 더할 경우 사용한다.
    + String + String 할경우 쓸데 없는 객체가 생성되서 GC가 자주 일어난다.
    + StringBuffer는 스레드에 안전한 프로그램이 필요할 때 사용한다.
    + StringBuilder는 스레드에 안전한지의 여부와 전혀 관계가 없는 프로그램을 개발할 때 사용한다.
  - 참고 : (http://12bme.tistory.com/42?category=682904)

4. 어디에 담아야 하는지...
  - Collection 인터페이스 구성
    + Collection : 가장 상위 인터페이스
    + set : 중복을 허용하지 않는 집합을 처리하기 위한 인터페이스
    + SortedSet : 오름차순을 갖는 Set인터페이스
    + List : 순서가 있는 집합을 처리하기 위한 인터페이스이기 떄문에 인덱스가 있어 위치를 지정하여 값을 찾을 수 있다. 중복을 허용하며, List 인터페이스를 상속받는 클래스 중에 가장 많이 사용하는 것으로 ArrayList가 있다.
    + Queue : 여러 개의 객체를 처리하기 전에 담아서 처리할 때 사용하기 위한 인터페이스이다. 기본적으로 FIFO(First In First Out)을 따른다.
    + Map : 키와 값의 쌍으로 구성된 객체의 집합을 처리하기 위한 인터페이스이다. 이 객체는 중복되는 키를 허용하지 않는다.
    + SortedMap : 키를 오름차순으로 정렬한다.
  - Set 인터페이스
    + HashSet : 데이터를 해쉬 테이블에 담는 클래스로 순서 없이 저장된다.
    + TreeSet : red-black(이진트리구조)이라는 트리에 데이터를 담는다. 값에 따라서 순서가 정해진다. 데이터를 담으면서 동시에 정렬을 하기 떄문에 HashSet보다 성능상 느리다.
    + LinkedHashSet : 해쉬테이블에 데이터를 담는데, 저장된 순서에 따라서 순서가 결정된다.
    + 데이터를 순서에 따라 탐색하는 작업이 필요할 떄는 TreeSet을 사용하는 것이 좋다. 하지만 그럴 필요가 없을때는 HashSet이나 LinkedHashSet을 사용하는 것을 권장한다.
  - List 인터페이스
    + 배열은 최초 선언시 담을 수 있는 데이터 개수가 한정 되어 있다. 하지만, List 인터페이스를 구현한 클래스들은 담을 수 있는 크기가 자동으로 증가된다.
    + Vector : 객체 생성시에 크기를 지정할 필요가 없는 배열 클래스이다.
    + ArrayList : Vector와 비슷하지만, 동기화 처리가 되어 있지 않다.
    + LinkedList : ArrayList와 동일하지만 Queue인터페이스를 구현했기 떄문에 FIFO 큐 잡업을 수행한다.
    + 성능상 차이 : ArrayList는 여러스레드에서 접근할 경우 문제가 발생할 수 있지만, Vector는 여러 스레드에서 접근할 경우를 방지하기 위해서 get()메서드 안에 Synchronized가 선언되어 있다. 따라서 성능 저하가 발생할 수 밖에 없다.
  - Map 인터페이스
    + Map은 key와 value의 쌍으로 저장되는 구조체이다.
    + 단일 객체만 저장되는 다른 Collection API들과는 다르게 따로 분리되어 있다.
    + HashTable : 데이터를 해쉬 테이블에 담는 클래스이다. 내부에서 관리하는 해쉬 테이블 객체가 동기화되어 있으므로, 동기화가 필요한 부분에서는 이 클래스를 사용하기 바란다.
    + HashMap : 데이터를 해쉬 테이블에 담는 클래스이다. HashTable 클래스와 다른점은 Null값을 허용한다는 것과 동기화가 되어 있지 않다는 것이다.
    + TreeMap : red-black 트리에 데이터를 담는다 TreeSet과 다른점은 키에 의해서 순서가 정해진다는 것이다.
    + LinkedHashMap : HashMap과 거의 동일하며 이중 연결 리스트라는 방식을 사용하여 데이터를 담는다는 점만 다르다.
      - 이중연결리스트 : 자료구조론에서 앞뒤 노드에 대한 링크 정보를 갖고 잇는 것을 말한다. 만약 앞의 링크값이 Null이거나 비어있으면 가장 첫 노드를 의미하며, 뒤의 링크값이 null이거나 비어있으면 가장 마지막 노드를 의미한다.
  - Queue 인터페이스
    + PriorityQueue : 큐에 추가된 순서와 상관없이 먼저 생성된 객체가 먼저 나오도록 되어있다.
    + LinkedBlockingQueue : 저장할 데이터의 크기를 선택적으로 정할 수도 있는 FIFO 기반의 링크노드를 사용하는 블로킹 큐다.
    + ArrayBlockingQueue : 저장되는 데이터의 크기가 정해져 있는 FIFO 기반의 블로킹 큐다.
    + PriorityBlockingQueue : 저장되는 데이터의 크기가 정해져 있지 않고, 객체의 생성순서에 따라서 순서가 저장되는 블로킹 큐다.
    + DelayQueue : 큐가 대기하는 시간을 지정하여 처리하도록 되어 있는 큐다.
    + SynchronousQueue : put()메서드를 호출하면, 다른 스레드에서 take() 메서드가 호출될 때까지 대기하도록 되어 있는 큐다. 이큐에 저장되는 데이터가 없다. API에서 제공하는 대부분의 메서드는 0이나 null을 리턴한다.
    + 참고 : 블로킹큐(blocking Queue)란 크기가 지정되어 있는 큐에 더 이상 공간이 없을 때, 공간이 생길 때까지 대기하도록 만들어진 큐를 의미한다.
  - Collection 인터페이스의 일반적인 사용
    + Set - > HashSet
    + List -> ArrayList
    + Map -> HashMap
    + Queue -> LinkedList

5. 지금 까지 사용하던 for 루프를 더 빠르게 할 수 있다고?
  - 자바의 JIT(Just In Time) 컴파일러 : JIT 컴파일(just-in-time compilation) 또는 동적 번역(dynamic translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. 이 기법은 프로그램의 실행 속도를 빠르게 하기 위해 사용된다.
  - For loop의 조건문에 ```list.size()```를 사용하면 반복할 때 마다 해당 메서드가 호출 된다. 변수를 선언하고 ```list.size()```를 초기화 한후 해당 변수를 조건문에 넣는것이 바람직하다.
  - For-Each를 사용하면 별도로 형변환한거나 get()메서드 또는 elementAt()메서드를 호출 할 필요없이 순서에 따라서 해당 객체를 사용할 수 있다. 단, 이방식은 데이터의 첫버째 값 부터 마지막까지 처리해야할 경우에만 유용하다. 만약 순서를 거꾸로 돌리거나, 특정 값부터 데이터를 탐색하는 경우에는 적절하지 않다.
6. static 제대로 한번 써 보자
  - HTTP상태코드
    + 200번대 : 정상적인 경우의 리턴코드
    + 300번대 : 리다이렉션이 필요한 경우의 리턴코드
    + 400번대 : 클라이언트 오류가 있을 경우 리턴코드
    + 500번대 : 서버에 오류가 있을 경우 리턴코드
  - static으로 선언한 class Variable은 클래스 변수라고 한다.
  - 100개의 VariableTypes 클래스의 인스턴스를 생성하더라도 모든 객체가 class Variable에 대해서는 동일한 주소의 값을 참조한다.
  - static블록은 클래스가 최초 로딩될 때 수행되므로 생성자 실행과 상관없이 수행된다.
  - static은 GC의 대상도 되지 않는다.
  - 자주 사용하고 절대 변하지 않는 변수는 final static으로 선언하자
  - static에 계속해서 데이터가 쌓이면 OutOfMemoryError가 발생한다. -> 시스템을 재기동해야한다.
  - 더 이상 사용가능한 메모리가 없어지는 현상을 메모리 릭(Memory Leak)이라고 한다.

7. 클래스 정보, 어떻게 알아낼 수 있나?
  - reflection패키지를 사용하면 JVM에 로딩되어 있는 클래스와 메서드 정보를 읽어 올 수 있다.
  - Class 클래스는 클래스에 대한 정보를 얻을 때 사용하기 좋고, 생성자는 따로 없다.
  - Method 클래스를 이용하여 메서드에 대한 정보를 얻을 수 있다. 하지만, Method클래스에는 생성자가 없으므로 Method클래스의 정보를 얻기 위해서는 Class 클래스의 getMethod()메서드를 사용하거나 getDeclareMethod()메서드를 써야한다.
  - Field 클래스는 클래스에 있는 변수들의 정보를 제공 한다. 생성자가 없으므로 Class클래스의 getField()메서드나 getDeclaredField() 메서드를 써야한다.
  - 객체를 비교할때는 리플렉션 정보(.getClass().getName())보다 instanceof를 사용하는게 성능상 좋다.
  - 클래스의 메타 데이터 정보는 JVM의 Perm영역에 저장된다. 만약 Class 클래스를 이용하여 엄청나게 많은 클래스를 동적으로 생성하는 일이 벌어지면 Perm 영역이 더이상 사용하 수 없게 되어 OutOfMemoryError가 발생할 수도 있다.

8. synchronized는 제대로 알고 써야 한다.
  - 클래스를 하나 수행시키거나 WAS를 기동하면, 서버에 자바 프로세스가 하나 생성된다.
  - 하나의 프로세스에는 여러개의 스레드가 생성된다. 단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있다.
  - 프로세스와 스레드의 관계는 1:다 관계다.
  - sleep()메서드는 명시된 시간만큼 해당 스레드를 대기시킨다.
  - wait()메서드도 명시된 시간만큼 대기시킨다. sleep()과 다른점은 매개변수인데, 만약 매개변수를 지정하지 않으면 notify()메서드 혹은 notifyAll()메서드가 호출될 때까지 대기한다.
  - join()메서드는 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 떄까지 계속 대기한다.
  - interrupt()메서드는 해당 스레드가 Block(대기상태)되거나 특정 상태에서만 동작하므로 항상 특정 스레드의 메서드를 멈출수 있는 것은 아니다.
  - synchronized는 메서드와 블록으로 사용할 수 있다. 절대로 생성자의 식별자로는 사용할 수 없다.
  - synchronized라는 식별자만 쓰면 동기화 할 수 있다.
  - synchronized로 동기화가 필요한 경우
    + 하나의 객체를 여러 스레드에서 동시에 사용 할 경우
    + static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

9. IO에서 발생하는 병목현상
  - New IO = NIO
  - 자바에서 입력과 출력은 스트림(Stream)을 통해서 이루어 진다.
  - 바이트 단위로 읽거나, 문자열 단위로 읽을 때 중요한 것은 한 번 Open한 스트림은 반드시 닫아 주어야 한다. 스트림을 닫지 않으면 나중에 리소스가 부족핼 질 수도 있다.
  - JDK6 까지는 자바에서 파일이 변경되었는지를 확인하기 위해서 File클래스에 있는 lastModified()라는 메서드를 사용했다. JDK7부터는 WatcherService를 사용한다.
